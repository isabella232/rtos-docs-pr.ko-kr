---
title: 3장 - Azure RTOS NetX Duo의 기능 구성 요소
description: 이 장에서는 기능 관점에서 고성능 Azure RTOS NetX Duo TCP/IP 스택에 관해 설명합니다.
author: philmea
ms.author: philmea
ms.date: 05/19/2020
ms.topic: article
ms.service: rtos
ms.openlocfilehash: c96e6e422ea570085f5d7c6aeaaaa697a2393b5e
ms.sourcegitcommit: 20a136b06a25e31bbde718b4d12a03ddd8db9051
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 09/07/2021
ms.locfileid: "123552384"
---
# <a name="chapter-3---functional-components-of-azure-rtos-netx-duo"></a>3장 - Azure RTOS NetX Duo의 기능 구성 요소

이 장에서는 기능 관점에서 고성능 Azure RTOS NetX Duo TCP/IP 스택에 관해 설명합니다. 

## <a name="execution-overview"></a>실행 개요

NetX Duo 애플리케이션 내에서는 프로그램이 초기화, 애플리케이션 인터페이스 호출, 내부 IP 스레드, IP 주기적 타이머, 네트워크 드라이버 등의 5가지 방식으로 실행됩니다.

> [!NOTE]
> NetX Duo는 ThreadX가 있는 것으로 가정하며 스레드 실행, 일시 중단, 주기적 타이머, 상호 배제 기능에 따라 달라집니다.

### <a name="initialization"></a>초기화

다른 NetX Duo 서비스를 호출하기 전에 ***nx_system_initialize** _ 서비스를 호출해야 합니다. ThreadX _ *_tx_application_define_** 함수나 애플리케이션 스레드에서 시스템 초기화를 호출할 수 있습니다.

***nx_system_initialize** _가 반환되면 시스템은 패킷 풀 및 IP 인스턴스를 만들 준비가 됩니다. IP 인스턴스를 만들려면 기본 패킷 풀이 필요하므로 IP 인스턴스를 만들기 전에 하나 이상의 NetX Duo 패킷 풀이 있어야 합니다. 패킷 풀 및 IP 인스턴스는 ThreadX 초기화 함수인 _ *_tx_application_define_** 및 애플리케이션 스레드에서 만들 수 있습니다.

내부적으로 IP 인스턴스를 만드는 작업은 두 부분으로 수행됩니다. 첫 번째 부분은 ***tx_application_define*** 또는 애플리케이션 스레드 컨텍스트의 호출자 컨텍스트 내에서 수행됩니다. 여기에는 IP 데이터 구조를 설정하고 내부 IP 스레드를 비롯한 다양한 IP 리소스를 만드는 작업이 포함됩니다. 두 번째 부분은 내부 IP 스레드에서 초기 실행 중에 수행됩니다. 여기서 IP 만들기의 첫 번째 부분을 수행하는 동안 제공되는 네트워크 드라이버를 먼저 호출합니다. 내부 IP 스레드에서 네트워크 드라이버를 호출하면 드라이버가 초기화 처리 중에 I/O를 수행 및 일시 중단할 수 있습니다.

네트워크 드라이버가 초기화 처리에서 반환되면 IP 생성이 완료됩니다.

NetX Duo에서 IPv6를 초기화하려면 몇 가지 추가 NetX Duo 서비스가 필요합니다. 해당 내용은 이 장의 뒷부분에 나오는 [NetX Duo의 IPv6](#ipv6-in-netx-duo) 섹션에 매우 자세히 설명되어 있습니다.

> [!NOTE]
> NetX Duo 서비스 **nx_ip_status_check** 는 IP 인스턴스 및 해당 기본 인터페이스 상태에 대한 정보를 가져오는 데 사용할 수 있습니다. 이러한 상태 정보에는 링크 초기화, 활성화, IP 주소 확인 여부가 포함됩니다. 이 정보는 새로 만든 IP 인스턴스 사용이 필요한 애플리케이션 스레드를 동기화하는 데 사용됩니다. 멀티홈 시스템의 경우 [멀티홈 지원](#multihome-support)을 참조하세요. **nx_ip_interface_/status_check** 를 사용하여 지정된 인터페이스에 대한 정보를 얻을 수 있습니다.

### <a name="application-interface-calls"></a>애플리케이션 인터페이스 호출

애플리케이션의 호출은 ThreadX RTOS에서 실행되는 애플리케이션 스레드에서 주로 수행됩니다. 그러나 일부 초기화, 만들기, 사용 서비스는 ***tx_application_define*** 에서 호출될 수 있습니다. [4장 - Azure RTOS NetX Duo 서비스 설명](chapter4.md)의 “허용되는 위치” 섹션에서는 각 NetX Duo 서비스를 호출할 수 있는 경우를 보여줍니다.

대부분의 경우, 체크섬 계산과 같은 집약적인 작업 처리는 IP 인스턴스에 대한 다른 스레드의 액세스를 차단하지 않고 호출 스레드의 컨텍스트 내에서 수행됩니다. 예를 들어 전송 시에는 기본 IP 전송 함수를 호출하기 전에 ***nx_udp_socket_send** _ 서비스 내에서 UDP 체크섬 계산이 수행됩니다. 수신된 패킷에서 UDP 체크섬은 애플리케이션 스레드의 컨텍스트에서 실행되는 _ *_nx_udp_socket_receive_** 서비스에서 계산됩니다. 이렇게 하면 우선 순위가 낮은 스레드에서 집약적인 체크섬 계산을 처리하므로 더 높은 우선 순위 스레드의 네트워크 요청이 지연되는 것을 방지할 수 있습니다.

IP 주소 및 포트 번호와 같은 값은 호스트 바이트 순서로 API에 전달됩니다. 내부적으로 이러한 값은 호스트 바이트 순서에도 저장됩니다. 이렇게 하면 개발자는 디버거를 통해 값을 쉽게 볼 수 있습니다. 이러한 값이 전송용 프레임으로 프로그래밍이 되면 네트워크 바이트 순서로 변환됩니다.

### <a name="internal-ip-thread"></a>내부 IP 스레드

설명한 대로 NetX Duo의 각 IP 인스턴스는 고유한 스레드를 가지고 있습니다. 내부 IP 스레드의 우선 순위 및 스택 크기는 ***nx_ip_create*** 서비스에 정의됩니다. 내부 IP 스레드가 실행 준비 모드에서 만들어집니다. IP 스레드의 우선 순위가 호출 스레드보다 높으면 IP 만들기 호출 내에서 선점이 발생할 수 있습니다.

내부 IP 스레드의 진입점은 내부 함수 _ ***nx_ip_thread_entry*** 에 있습니다. 시작할 때, 내부 IP 스레드는 먼저 애플리케이션별 네트워크 드라이버에 대한 세 번의 호출로 구성된 네트워크 드라이버 초기화를 완료합니다. 첫 번째 호출은 네트워크 드라이버를 IP 인스턴스에 연결한 후 초기화 호출을 통해 네트워크 드라이버가 초기화 프로세스를 수행하게 합니다. 네트워크 드라이버가 초기화에서 반환된 후(하드웨어가 제대로 설정되기를 기다리는 동안 일시 중단될 수 있음) 내부 IP 스레드가 네트워크 드라이버를 다시 호출하여 링크를 사용하도록 설정합니다. 네트워크 드라이버가 링크 사용 호출에서 반환된 후 내부 IP 스레드는 이 IP 인스턴스에 대한 처리가 필요한 다양한 이벤트를 확인하는 영구 루프 검사를 수행합니다. 이 루프에서 처리되는 이벤트에는 지연된 IP 패킷 수신, IP 패킷 조각 어셈블리, ICMP ping 처리, IGMP 처리, TCP 패킷 큐 처리, TCP 주기적 처리, IP 조각 어셈블리 시간 제한, IGMP 주기적 처리가 포함됩니다. 또한 이벤트에는 주소 확인 작업, IPv4의 ARP 패킷 처리 및 ARP 주기적 처리, 중복 주소 검색, 라우터 요청, IPv6의 인접 노드 검색이 포함됩니다.

> [!CAUTION]
> 수신 대기 및 연결 해제 콜백을 포함한 NetX Duo 콜백 함수는 원래 호출 스레드가 아닌 내부 IP 스레드에서 호출됩니다. 애플리케이션은 NetX Duo 콜백 함수 내에서 일시 중단되지 않도록 주의해야 합니다.

### <a name="ip-periodic-timers"></a>IP 주기적 타이머

각 IP 인스턴스에는 두 개의 ThreadX 주기적 타이머가 사용됩니다. 첫 번째 타이머는 ARP, IGMP, TCP 시간 제한에 대한 1초 타이머이며 또한 IP 조각 리어셈블 처리도 구동합니다. 두 번째 타이머는 TCP 재전송 시간 제한 및 IPv6 관련 작업을 구동하는 100ms 타이머입니다.

### <a name="network-driver"></a>네트워크 드라이버

NetX Duo의 각 IP 인스턴스는 ***nx_ip_create*** 서비스에 지정된 디바이스 드라이버로 식별되는 기본 인터페이스를 포함합니다. 네트워크 드라이버는 패킷 전송, 패킷 수신, 상태 및 제어 요청을 포함한 다양한 NetX Duo 요청을 처리해야 합니다. 

멀티홈 시스템의 경우 IP 인스턴스는 각 해당 인터페이스에 대해 이러한 작업을 수행하는 연결된 네트워크 드라이버를 가진 여러 인터페이스를 포함합니다.

또한 네트워크 드라이버는 미디어에서 발생하는 비동기 이벤트도 처리해야 합니다. 미디어의 비동기 이벤트에는 패킷 수신, 패킷 전송 완료, 상태 변경이 포함됩니다. NetX Duo는 다양한 이벤트 처리를 위한 여러 액세스 함수를 포함하는 네트워크 드라이버를 제공합니다. 이러한 함수는 네트워크 드라이버의 인터럽트 서비스 루틴 부분에서 호출되도록 설계되었습니다. IPv4 네트워크의 경우 네트워크 드라이버가 수신한 모든 ARP 패킷을 ***_nx_arp_packet_deferred_receive*** 내부 함수로 전달해야 합니다. 모든 RARP 패킷은 * **_nx_rarp_packet_deferred_receive** _ 내부 함수로 전달되어야 합니다. IP 패킷에는 두 가지 옵션이 있습니다. IP 패킷을 빠르게 디스패치해야 하는 경우 들어오는 IP 패킷을 _ *_ _nx_ip_packet_receive_* _로 전달하여 즉시 처리해야 합니다. 이렇게 하면 NetX Duo의 IP 패킷 처리 성능이 크게 향상됩니다. 그러지 않으면 IP 패킷을 _ *_ _nx_ip_packet_deferred_receive_**로 전달해야 합니다. 이 서비스는 IP 패킷을 지연된 처리 큐에 배치한 다음, 이 큐에서 내부 IP 스레드에 의해 처리되므로 ISR 처리 시간이 최소화됩니다.

네트워크 드라이버는 IP 스레드의 컨텍스트에서 실행되기 위해 인터럽트 처리를 연기할 수도 있습니다. 이 모드에서 ISR은 필요한 정보를 저장하고 내부 함수 ***_nx_ip_driver_deferred_processing*** 을 호출하여 인터럽트 컨트롤러를 승인해야 합니다. 이 서비스는 디바이스 드라이버에 대한 콜백을 예약하여 인터럽트를 유발하는 이벤트 프로세스를 완료하도록 IP 스레드에 알립니다.

일부 네트워크 컨트롤러는 유용한 CPU 리소스를 차지하지 않고도 TCP/IP 헤더 체크섬 계산 및 하드웨어의 유효성 검사를 수행할 수 있습니다. 하드웨어 기능을 활용하기 위해 NetX Duo는 컴파일 시 다양한 소프트웨어 체크섬 계산을 사용하거나 또는 사용하지 않도록 옵션을 제공하고, 디바이스 드라이버가 하드웨어 기능에 대해 IP 계층과 통신할 수 있는 경우 런타임에 체크섬 계산을 설정하거나 해제하는 옵션도 제공합니다. NetX Duo 네트워크 드라이버 작성에 대한 자세한 내용은 [5장 - Azure RTOS NetX Duo 네트워크 드라이버](chapter5.md)를 참조하세요.

### <a name="multihome-support"></a>멀티홈 지원

NetX Duo는 단일 IP 인스턴스를 사용하여 여러 실제 디바이스에 연결된 시스템을 지원합니다. 각 실제 인터페이스는 IP 인스턴스의 인터페이스 제어 블록에 할당됩니다. 멀티홈 시스템을 사용하려는 애플리케이션은 시스템에 연결된 실제 디바이스 수로 ***NX_MAX_PHSYCIAL_INTERFACES** _ 값을 정의하고 NetX Duo 라이브러리를 다시 빌드해야 합니다. 기본적으로 _ *_NX_MAX_PHYSICAL_INTERFACES_**는 하나로 설정되고, IP 인스턴스에서 하나의 인터페이스 제어 블록을 만듭니다.

NetX Duo 애플리케이션은 ***nx_ip_create** _ 서비스를 사용하여 기본 디바이스를 위한 단일 IP 인스턴스를 만듭니다. 애플리케이션은 각 추가 네트워크 디바이스에 대해 _ *_nx_ip_interface_attach_** 서비스를 사용하여 IP 인스턴스에 디바이스를 연결합니다.

각 네트워크 인터페이스 구조에는 인터페이스 IPv4 주소, 서브넷 마스크, IP MTU 크기, MAC 계층 주소 정보를 포함하여 IP 제어 블록에 포함된 네트워크 인터페이스에 대한 네트워크 정보의 하위 집합이 포함되어 있습니다.

> [!NOTE]
> 멀티홈을 지원하는 NetX Duo는 이전 버전의 NetX Duo와 호환됩니다. 명시적 인터페이스 정보를 사용하지 않는 서비스는 기본 네트워크 디바이스로 기본 설정됩니다.

기본 인터페이스의 IP 인스턴스 목록에 인덱스 0이 있습니다. IP 인스턴스에 연결된 각 후속 디바이스에는 다음 인덱스가 할당됩니다.

TCP, UDP, ICMP, IGMP를 포함하여 IP 인스턴스를 사용하는 모든 상위 계층 프로토콜 서비스를 연결된 모든 디바이스에서 사용할 수 있습니다.

대부분의 경우 NetX Duo는 패킷을 전송할 때 사용할 가장 적합한 소스 주소를 확인할 수 있습니다. 소스 주소 선택은 대상 주소를 기반으로 합니다. 대상 주소에서 최적의 주소를 결정할 수 없는 경우 애플리케이션에서 사용할 특정 소스 주소를 지정할 수 있도록 NetX Duo 서비스가 추가됩니다. 예를 들어, 멀티홈 시스템에서 애플리케이션은 IPv4 브로드캐스트 또는 멀티캐스트 대상 주소로 패킷을 전송해야 합니다.

멀티홈 애플리케이션 개발을 위한 서비스는 다음과 같습니다.

- *nx_igmp_multicast_interface_join*
- *nx_igmp_multicast_interface_leave*
- *nx_ip_driver_interface_direct_command*
- *nx_ip_interface_address_get*
- *nx_ip_interface_address_mapping_configure*
- *nx_ip_interface_address_set*  
- *nx_ip_interface_attach*
- *nx_ip_interface_capability_get* 
- *nx_ip_interface_capability_set*
- *nx_ip_interface_detach*
- *nx_ip_interface_info_get*
- *nx_ip_interface_mtu_set*
- *nx_ip_interface_physical_address_get*
- *nx_ip_interface_physical_address_set*
- *nx_ip_interface_status_check*
- *nx_ip_raw_packet_source_send*
- *nx_ipv4_multicast_interface_join*
- *nx_ipv4_multicast_interface_leave*
- *nx_udp_socket_source_send*
- *nxd_ipv6_multicast_interface_join*
- *nxd_ipv6_multicast_interface_leave* 
- *nxd_udp_socket_source_send*
- *nxd_icmp_source_ping*
- *nxd_ip_raw_packet_source_send*
- *nxd_udp_socket_source_send*

이러한 서비스는 [NetX Duo 서비스 설명](chapter4.md)에 자세히 설명되어 있습니다.

### <a name="loopback-interface"></a>루프백 인터페이스

루프백 인터페이스는 실제 링크가 연결되어 있지 않은 특수한 네트워크 인터페이스입니다. 루프백 인터페이스를 통해 애플리케이션은 IPv4 루프백 주소 127.0.0.1을 사용하여 통신할 수 있습니다. 논리적 루프백 인터페이스를 활용하려면 구성 가능한 옵션 ***NX_DISABLE_LOOPBACK_INTERFACE*** 가 설정되어 있지 않았는지 확인합니다.

### <a name="interface-control-blocks"></a>인터페이스 제어 블록

IP 인스턴스의 인터페이스 제어 블록 수는 실제 인터페이스(***NX_MAX_PHYSICAL_INTERFACES** _로 정의됨)의 수와 루프백 인터페이스(사용 가능한 경우) 수를 더한 값과 같습니다. 총 인터페이스 수는 _*_NX_MAX_IP_INTERFACES_**에 정의되어 있습니다.

## <a name="protocol-layering"></a>프로토콜 계층화

NetX Duo에 의해 구현된 TCP/IP는 계층화된 프로토콜로, 더 복잡한 프로토콜이 더 단순한 기본 프로토콜을 기반으로 하여 빌드됩니다. TCP/IP에서 가장 낮은 계층 프로토콜은 ‘링크 수준’에 있으며 네트워크 드라이버에서 처리됩니다. 이 수준은 일반적으로 이더넷을 대상으로 하지만 파이버, 시리얼 또는 거의 모든 실제 미디어를 대상으로 할 수도 있습니다.

링크 계층의 맨 위에는 ‘네트워크 계층’이 있습니다. TCP/IP에서 이것은 기본적으로 네트워크를 통해 간단한 패킷을 최선의 방법으로 주고받는 것을 담당하는 IP입니다. ICMP 및 IGMP와 같은 관리 형식 프로토콜은 일반적으로 IP를 주고받는 경우에도 네트워크 계층으로 분류됩니다.

‘전송 계층’은 네트워크 계층의 맨 위에 있습니다. 이 계층은 네트워크의 호스트 간 데이터 흐름을 관리해야 합니다. NetX Duo에서 지원하는 전송 서비스에는 UDP 및 TCP의 두 가지 형식이 있습니다. UDP 서비스는 연결하지 않고 두 호스트 간에 데이터를 주고받는 최선의 방법을 제공하는 반면, TCP는 두 호스트 엔터티 간에 안정적인 연결 지향 서비스를 제공합니다.

이 계층은 실제 네트워크 데이터 패킷에 반영됩니다. TCP/IP의 각 계층에는 헤더라는 정보 블록이 포함되어 있습니다. 헤더를 사용하여 데이터(및 프로토콜 정보)를 둘러싸는 이 기술을 일반적으로 데이터 캡슐화라고 합니다. 그림 1은 NetX Duo 계층화의 예를 보여주고 그림 2는 전송 중인 UDP 데이터에 대한 데이터 캡슐화 결과의 예를 보여줍니다.

![프로토콜 계층화](./media/user-guide/image12.jpg)

**그림 1. 프로토콜 계층화**

## <a name="packet-pools"></a>패킷 풀

실시간 네트워킹 애플리케이션에서 신속하고 결정적인 방식으로 패킷을 할당하는 것은 항상 어려운 과제입니다. 이를 염두에 둔 NetX Duo는 고정 크기 네트워크 패킷의 여러 풀을 만들고 관리할 수 있는 기능을 제공합니다.

NetX Duo 패킷 풀은 고정 크기의 메모리 블록으로 구성되므로 내부 조각화 문제가 발생하지 않습니다. 물론 조각화는 본질적으로 비결정적인 동작을 야기합니다. 더불어, NetX Duo 패킷을 할당하고 해제하는 데 필요한 시간은 간단한 연결된 목록 조작에 해당합니다. 또한 패킷 할당 및 할당 해제는 사용 가능한 목록의 맨 위에서 수행됩니다. 이렇게 하면 가장 빠른 연결된 목록 처리를 수행할 수 있습니다.

![UDP 데이터 캡슐화](./media/user-guide/image13.png)

**그림 2. UDP 데이터 캡슐화**

일반적으로 유연성 부족은 고정 크기 패킷 풀의 주요 단점입니다. 최악의 경우 들어오는 패킷을 처리하는 최적의 패킷 페이로드 크기를 결정하는 것은 어려운 작업입니다. NetX Duo 패킷은 패킷 연결이라는 옵션 기능을 사용하여 이 문제를 해결합니다. 실제 네트워크 패킷은 함께 연결된 두 개 이상의 NetX Duo 패킷으로 구성될 수 있습니다. 또한 패킷 헤더는 패킷의 맨 위에 대한 포인터를 유지합니다. 추가 프로토콜이 추가되면 이 포인터는 단순히 뒤로 이동하고 새 헤더는 데이터 바로 앞에 작성됩니다. 유연한 패킷 기술이 없으면 스택은 처리 집약적인 새 헤더를 사용하여 다른 버퍼를 할당하고 데이터를 새 버퍼에 복사해야 합니다.

각 패킷 페이로드 크기는 지정된 패킷 풀에 대해 고정되므로 페이로드 크기보다 큰 애플리케이션 데이터에는 여러 패킷이 함께 연결되어 있어야 합니다. 사용자 데이터를 사용하여 패킷을 채울 때 애플리케이션은 ***nx_packet_data_append*** 서비스를 사용해야 합니다. 이 서비스는 애플리케이션 데이터를 패킷으로 이동합니다. 패킷이 사용자 데이터를 저장하기에 충분하지 않은 경우 사용자 데이터를 저장하기 위한 추가 패킷이 할당됩니다. 패킷 연결을 사용하려면 드라이버에서 연결된 패킷으로 수신하거나 전송할 수 있어야 합니다.

패킷 연결 기능을 사용할 필요가 없는 포함된 시스템의 경우 ***NX_DISABLE_PACKET_CHAIN** _으로 NetX Duo 라이브러리를 빌드하여 패킷 연결 논리를 제거할 수 있습니다. IP 조각화 및 리어셈블리 기능은 연결된 패킷 기능을 활용해야 할 수 있습니다. 따라서 _*_NX_DISABLE_PACKET_CHAIN_*_ 을 정의하려면 _ *_NX_DISABLE_FRAGMENTATION_**도 정의해야 합니다. 

각 NetX Duo 패킷 메모리 풀은 퍼블릭 리소스입니다. NetX Duo는 패킷 풀의 사용 방법에 제약 조건을 두지 않습니다. 

### <a name="packet-pool-memory-area"></a>패킷 풀 메모리 영역

패킷 풀의 메모리 영역은 만드는 동안 지정됩니다. ThreadX 및 NetX Duo 개체의 다른 메모리 영역과 마찬가지로 대상의 주소 공간 어디에서나 찾을 수 있습니다. 

이는 애플리케이션에 상당한 유연성을 제공하기 때문에 중요한 기능입니다. 예를 들어 통신 제품에 네트워크 버퍼를 위한 고속 메모리 영역이 있다고 가정합니다. 이 메모리 영역은 NetX Duo 패킷 메모리 풀로 만들어 쉽게 활용할 수 있습니다.

### <a name="creating-packet-pools"></a>패킷 풀 만들기

패킷 풀은 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 만들어집니다. NetX Duo 애플리케이션의 패킷 메모리 풀 수에는 제한이 없습니다.

### <a name="dual-packet-pool"></a>이중 패킷 풀

일반적으로 기본 IP 패킷 풀의 페이로드 크기는 네트워크 인터페이스 MTU까지 프레임 크기를 수용할 수 있을 만큼 충분히 큽니다. 정상적인 작업 중에 IP 스레드는 ARP, TCP 제어 메시지, IGMP 메시지, ICMPv6 메시지 등의 메시지를 보내야 합니다. 이러한 메시지는 IP 인스턴스의 기본 패킷 풀에서 할당된 패킷을 사용합니다. 패킷 풀에 사용할 수 있는 메모리양이 제한된 메모리 제약 시스템에서는 MTU 크기에 맞게 큰 페이로드 크기를 가진 단일 패킷 풀을 사용하는 것이 최적의 솔루션이 아닐 수 있습니다. NetX Duo를 사용하면 애플리케이션은 페이로드 크기가 더 작은 보조 패킷 풀을 설치할 수 있습니다. 보조 패킷 풀이 설치되면 IP 도우미 스레드는 전송하는 메시지 크기에 따라 기본 패킷 풀이나 보조 풀에서 패킷을 할당합니다. 보조 패킷 풀의 경우 IP 도우미 스레드가 전송하는 대부분의 메시지에서 200바이트의 페이로드 크기가 작동합니다.

기본적으로 NetX Duo 라이브러리는 이중 패킷 풀을 사용하지 않고 빌드됩니다. 기능을 사용하도록 설정하려면 ***NX_DUAL_PACKET_POOL_ENABLE** _이 정의된 라이브러리를 빌드합니다. 그런 다음 _*_nx_ip_auxiliary_packet_pool_set_**을 호출하여 보조 패킷 풀을 설정할 수 있습니다.

또한 두 개 이상의 패킷 풀을 만드는 옵션도 있습니다. 예를 들어 전송 패킷 풀은 예상 메시지 크기에 대한 최적의 페이로드 크기로 만들어집니다. 수신된 패킷의 크기를 예측할 수 없기 때문에 드라이버 MTU로 설정된 페이로드 크기의 드라이버에 수신 패킷 풀이 만들어집니다.

### <a name="packet-header-nx_packet"></a>패킷 헤더 NX_PACKET   
기본적으로 NetX Duo는 패킷 페이로드 영역 바로 앞에 패킷 헤더를 배치합니다. 패킷 메모리 풀은 기본적으로 일련의 패킷이며 헤더 바로 뒤에 패킷 페이로드가 배치됩니다. 패킷 헤더(***NX_PACKET***)와 패킷 풀의 레이아웃은 그림 3에 나와 있습니다.

무복사 작업을 수행할 수 있는 네트워크 디바이스 드라이버의 경우 일반적으로 패킷 페이로드 영역의 시작 주소가 DMA 논리로 프로그래밍이 됩니다. 특정 DMA 엔진은 페이로드 영역에 맞춤 요구 사항이 있습니다. 페이로드 영역의 시작 주소를 DMA 엔진 또는 캐시 작업에 올바르게 맞추려면 사용자는 기호 ***NX_PACKET_ALIGNMENT*** 를 정의할 수 있습니다.

> [!WARNING]
> 패킷 전송이 완료되면 네트워크 드라이버에서 **nx_packet_transmit_release** 함수를 사용하는 것이 중요합니다. 이 함수는 실제로 사용 가능한 풀에 다시 배치되기 전에 패킷이 TCP 출력 큐의 일부가 아닌지 확인합니다.

![패킷 헤더 및 패킷 풀 레이아웃](./media/user-guide/image14.jpg)

**그림 3. 패킷 헤더 및 패킷 풀 레이아웃**

패킷 헤더의 필드는 다음과 같이 정의됩니다. 이 표는 *NX_PACKET* 구조에 있는 모든 멤버의 포괄적인 목록은 아닙니다.

|패킷 헤더 | 목적 |
|---|---|
|***nx_packet_pool_owner***|이 필드는 이 특정 패킷을 소유한 패킷 풀을 가리킵니다. 패킷이 해제되면 이 특정 풀로 해제됩니다. 각 패킷 내부의 풀 소유권을 통해 데이터그램이 여러 패킷 풀에서 여러 패킷을 소유할 수 있습니다.|
|***nx_packet_next** _|이 필드는 동일한 프레임 내의 다음 패킷을 가리킵니다. NULL인 경우 프레임의 일부인 추가 패킷이 없습니다. 이 필드는 전체 패킷을 다시 어셈블할 수 있을 때까지 조각난 패킷을 보관하는 데도 사용됩니다. _*_NX_DISABLE_PACKET_CHAIN_**이 정의되면 제거됩니다.|
|***nx_packet_last** _|이 필드는 동일한 네트워크 패킷 내의 마지막 패킷을 가리킵니다. NULL인 경우 이 패킷은 전체 네트워크 패킷을 나타냅니다. _*_NX_DISABLE_PACKET_CHAIN_**이 정의되면 이 필드는 제거됩니다.|
|***nx_packet_length** _| 이 필드는 _nx_packet_next* 멤버에 의해 함께 연결된 모든 패킷의 모든 바이트 수를 포함하여 전체 네트워크 패킷의 총 바이트 수를 포함합니다.|
|***nx_packet_ip_interface***| 이 필드는 인터페이스 드라이버에 의해 수신될 때 패킷에 할당되고, NetX Duo에 의해 나가는 패킷에 할당되는 인터페이스 제어 블록입니다. 인터페이스 제어 블록은 네트워크 주소, MAC 주소, IP 주소 등의 인터페이스 및 링크 사용이나 실제 매핑 필요와 같은 인터페이스 상태를 설명합니다.|
|***nx_packet_data_start** _| 이 필드는 이 패킷의 실제 페이로드 영역의 시작을 가리킵니다. NX_PACKET 헤더 바로 뒤에 있을 필요는 없지만 _ *_nx_packet_pool_create_* 서비스에 대한 기본값입니다.|
|***nx_packet_data_end** _|이 필드는 이 패킷의 실제 페이로드 영역의 끝을 가리킵니다. 이 필드와 _nx_packet_data_start* 필드 간의 차이는 페이로드 크기를 나타냅니다.|
|***nx_packet_prepend_ptr** _|이 필드는 패킷 페이로드 영역의 기존 패킷 데이터(있는 경우) 앞에 프로토콜 헤더나 실제 데이터와 같은 패킷 데이터가 추가되는 위치를 가리킵니다. _nx_packet_data_start* 포인터 위치보다 크거나 같아야 하며 *nx_packet_append_ptr* 포인터보다 작거나 같아야 합니다.|
> [!CAUTION]
> 성능상의 이유로, 전송을 위해 패킷이 NetX Duo 서비스에 전달될 때 NetX Duo는 앞에 추가 포인터가 긴 단어 맞춤 주소를 가리키는 것으로 가정합니다.

| 패킷 헤더 | 목적 |
|---|---|
|***nx_packet_append_ptr** _|이 필드는 현재 패킷 페이로드 영역에 있는 데이터의 끝을 가리킵니다. _nx_packet_prepend_ptr* 및 *nx_packet_data_end.* 가 가리키는 메모리 위치 사이에 있어야 합니다. 이 필드와 *nx_packet_prepend_ptr* 필드 간의 차이는 이 패킷의 데이터양을 나타냅니다.|
|***nx_packet_packet_pad** _|이 필드는 원하는 맞춤 요구 사항을 달성하기 위해 4바이트 단어로 된 패딩의 길이를 정의합니다. _*_NX_PACKET_HEADER_PAD_*_ 가 정의되지 않은 경우 이 필드는 제거됩니다. 또는 _nx_packet_header_pad를 정의하는 대신 _*_NX_PACKET_ALIGNMENT_*_ 를 사용할 수 있습니다.*|

### <a name="packet-header-offsets"></a>패킷 헤더 오프셋

패킷 헤더 크기는 헤더 크기를 수용할 수 있는 충분한 공간을 허용하도록 정의됩니다. ***nx_packet_allocate*** 서비스는 패킷을 할당하고 지정된 패킷 형식에 따라 패킷의 앞에 추가 포인터를 조정하는 데 사용됩니다. 패킷 형식은 프로토콜 헤더(예: UDP, TCP, ICMP)를 프로토콜 데이터 앞에 삽입하는 데 필요한 오프셋을 NetX Duo에게 알려줍니다.

다음 형식은 패킷의 IP 헤더와 실제 계층(이더넷) 헤더를 고려하도록 NetX Duo에서 정의됩니다. 후자의 경우, 필요한 4바이트 맞춤을 고려하여 16바이트로 가정합니다. IPv4 패킷은 IPv4 네트워크의 패킷을 할당하는 애플리케이션에 대해 NetX Duo에서 계속 정의됩니다. NetX Duo 라이브러리가 IPv6를 사용하도록 설정하여 빌드된 경우 일반 패킷 형식(예: NX_IP_PACKET)은 IPv6 버전에 매핑됩니다. IPv6를 사용하도록 설정하지 않고 NetX Duo 라이브러리를 빌드하면 이러한 일반 패킷 형식은 IPv4 버전에 매핑됩니다.

다음 표에서는 IPv6를 사용하도록 설정하여 정의된 기호를 보여 줍니다.

|**패킷 형식** |**값** |
|---|---|
|NX_IPv6_PACKET(NX_IP_PACKET) | 0x38 |
|NX_UDPv6_PACKET(NX_UDP_PACKET) |0x40 |
|NX_TCPv6_PACKET(NX_TCP_PACKET) |0x4c |
|NX_IPv4_PACKET |0x24 |
|NX_IPv4_UDP_PACKET |0x2c |
|NX_IPv4_TCP_PACKET |0x38 |

다음 표에서는 IPv6를 사용하지 않도록 설정하여 정의된 기호를 보여 줍니다.

|**패킷 형식** |**값** |
|---|---|
|NX_IPv4_PACKET(NX_IP_PACKET) |0x24 |
|NX_IPv4_UDP_PACKET(NX_UDP_PACKET) |0x2c |
|NX_IPv4_TCP_PACKET(NX_TCP_PACKET) |0x38 |

*NX_IPSEC_ENABLE* 이 정의된 경우 이러한 값은 변경됩니다. IPsec을 사용하는 애플리케이션에 대한 자세한 정보는 NetX Duo IPsec 사용자 가이드를 참조하세요.

### <a name="pool-capacity"></a>풀 용량

패킷 풀의 패킷 수는 페이로드 크기와 패킷 풀 만들기 서비스에 제공된 메모리 영역의 총 바이트 수의 함수입니다. 풀의 용량은 패킷 크기(NX_PACKET 헤더의 크기, 페이로드 크기, 올바른 맞춤 포함)를 제공된 메모리 영역의 총 바이트 수로 나누어 계산합니다.

### <a name="payload-area-alignment"></a>페이로드 영역 맞춤

NetX Duo의 패킷 풀 디자인은 무복사를 지원합니다. 디바이스 드라이버 수준에서 드라이버는 데이터 수신에 대해 페이로드 영역을 버퍼 설명자에 직접 할당할 수 있습니다. 경우에 따라 DMA 엔진 또는 캐시 동기화 메커니즘은 특정한 맞춤 요구 사항을 충족하기 위해 페이로드 영역의 시작 주소가 필요합니다. 이는 ***NX_PACKET_ALIGNMENT*** 에서 원하는 맞춤 요구 사항(바이트)을 정의하여 달성할 수 있습니다. 패킷 풀을 만들 때 페이로드 영역의 시작 주소가 이 값에 맞춰집니다. 기본적으로 시작 주소는 4바이트 맞춤입니다.

### <a name="thread-suspension"></a>스레드 일시 중단

빈 풀에서 패킷을 기다리는 동안 애플리케이션 스레드가 일시 중단될 수 있습니다. 패킷이 풀로 반환되면 일시 중단된 스레드에 이 패킷이 제공되고 다시 시작됩니다.

여러 스레드가 동일한 패킷 풀에서 일시 중단되면 일시 중단된 순서대로(FIFO) 다시 시작됩니다.

### <a name="pool-statistics-and-errors"></a>풀 통계 및 오류

사용하도록 설정된 경우 NetX Duo 패킷 관리 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다. 패킷 풀에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.

- 풀의 총 패킷
- 풀의 사용 가능한 패킷
- 총 패킷 할당
- 풀 빈 할당 요청
- 풀 빈 할당 일시 중단
- 잘못된 패킷 릴리스

***NX_DISABLE_PACKET_INFO** _가 정의되어 있지 않은 경우 풀의 총 패킷 수와 사용 가능한 패킷 수를 제외한 모든 통계 및 오류 보고서는 NetX Duo 라이브러리에 내장되어 있습니다. 이 데이터는 애플리케이션이 _ *_nx_packet_pool_info_get_** 서비스를 통해 사용할 수 있습니다.

### <a name="packet-pool-control-block-nx_packet_pool"></a>패킷 풀 제어 블록 NX_PACKET_POOL

각 패킷 메모리 풀의 특성은 해당 제어 블록에서 찾을 수 있습니다. 이 풀에는 사용 가능한 패킷의 연결된 목록, 사용 가능한 패킷 수, 이 풀의 패킷에 대한 페이로드 크기와 같은 유용한 정보가 포함되어 있습니다. 이 구조는 ***nx_api.h*** 파일에서 정의됩니다.

패킷 풀 제어 블록은 메모리 내 어디에나 위치할 수 있지만, 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.

## <a name="ipv4-protocol"></a>IPv4 프로토콜

NetX Duo의 IP(인터넷 프로토콜) 구성 요소는 인터넷에서 IPv4 패킷을 주고받는 역할을 합니다. NetX Duo에서 기본 네트워크 드라이버를 활용하여 TCP, UDP, ICMP, IGMP 메시지를 최종적으로 주고받는 구성 요소입니다.

NetX Duo는 IPv4 프로토콜(RFC 791) 및 IPv6 프로토콜(RFC 2460)을 모두 지원합니다. 이 섹션에서는 IPv4에 대해 설명합니다. IPv6는 다음 섹션에서 설명합니다.

### <a name="ipv4-addresses"></a>IPv4 주소

인터넷의 각 호스트에는 IP 주소라는 고유한 32비트 식별자가 있습니다. 그림 4에 설명된 대로 IPv4 주소에는 5개의 클래스가 있습니다. 5개의 IPv4 주소 클래스의 범위는 다음과 같습니다.

|클래스|범위|
|---|---|
|A |0.0.0.0~127.255.255.255|
|b |128.0.0.0~191.255.255.255|
|C |192.0.0.0~223.255.255.255|
|D |224.0.0.0~239.255.255.255|
|E |240.0.0.0~247.255.255.255|

![IPv4 주소 구조의 다이어그램입니다.](./media/user-guide/ipv4-address-structure.png)

### <a name="figure-4-ipv4-address-structure"></a>그림 4. IPv4 주소 구조

또한 주소 사양에는 ‘유니캐스트’, ‘브로드캐스트’, ‘멀티캐스트’의 세 가지 형식이 있습니다.   유니캐스트 주소는 인터넷에서 특정 호스트를 식별하는 IPv4 주소입니다. 유니캐스트 주소는 소스 또는 대상 IPv4 주소일 수 있습니다. 브로드캐스트 주소는 특정 네트워크 또는 하위 네트워크의 모든 호스트를 식별하고 대상 주소로만 사용될 수 있습니다. 브로드캐스트 주소는 주소의 호스트 ID 부분을 하나로 설정하여 지정합니다. 멀티캐스트 주소(클래스 D)는 인터넷에서 동적 호스트 그룹을 지정합니다. 멀티캐스트 그룹의 멤버는 언제든지 가입하고 탈퇴할 수 있습니다.

> [!IMPORTANT]
> IPv4를 통한 UDP와 같은 연결 없는 프로토콜만이 브로드캐스트와 멀티캐스트 그룹의 제한된 브로드캐스트 기능을 이용할 수 있습니다.

> [!IMPORTANT]
> *매크로 *IP_ADDRESS* 는 ***nx_api.h** _에 정의됩니다. 마침표 대신 쉼표를 사용하여 IPv4 주소를 쉽게 지정할 수 있습니다. 예를 들어 _IP_ADDRESS(128,0,0,0)*는 그림 4에 표시된 첫 번째 클래스 B 주소를 지정합니다.*

### <a name="ipv4-gateway-address"></a>IPv4 게이트웨이 주소

네트워크 게이트웨이는 네트워크의 호스트가 로컬 도메인 외부의 대상으로 향하는 패킷을 릴레이하도록 지원합니다. 각 노드는 인접 노드 중 하나 또는 미리 프로그래밍이 된 고정 라우팅 테이블을 통해 다음 홉을 전송할 대상에 대한 약간의 정보를 가지고 있습니다. 그러나 이러한 접근 방식이 실패할 경우 노드는 패킷을 대상으로 라우팅하는 방법에 대한 더 나은 정보를 가진 기본 게이트웨이로 패킷을 전달해야 합니다. 기본 게이트웨이는 IP 인스턴스에 연결된 실제 인터페이스 중 하나를 통해 직접 액세스할 수 있어야 합니다. 애플리케이션은 IPv4 기본 게이트웨이 주소를 구성하기 위해 ***nx_ip_gateway_address_set** _을 호출합니다. _*_nx_ip_gateway_address_get_*_ 서비스를 사용하여 현재 IPv4 게이트웨이 설정을 검색합니다. 애플리케이션은 _ *_nx_ip_gateway_address_clear_** 서비스를 사용하여 게이트웨이 설정을 지워야 합니다.

### <a name="ipv4-header"></a>IPv4 헤더

인터넷에서 IPv4 패킷을 전송하려면 IPv4 헤더가 있어야 합니다. 상위 수준의 프로토콜(UDP, TCP, ICMP, IGMP)이 패킷을 전송하기 위해 IP 구성 요소를 호출할 때 IPv4 전송 모듈은 데이터 앞에 IPv4 헤더를 배치합니다. 반대로, IP 패킷이 네트워크에서 수신되면, IP 구성 요소는 상위 수준의 프로토콜로 전송되기 전에 패킷에서 IPv4 헤더를 제거합니다. 그림 5는 IP 헤더의 형식을 보여줍니다.

![IPv4 헤더 형식](./media/user-guide/ipv4-header-format.png)

### <a name="figure-5-ipv4-header-format"></a>그림 5. IPv4 헤더 형식

> [!IMPORTANT]
> TCP/IP 구현의 모든 헤더는 **big endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다. 예를 들어 IP 헤더의 4비트 버전과 4비트 헤더 길이는 헤더의 첫 번째 바이트에 위치해야 합니다.

IPv4 헤더의 필드는 다음과 같이 정의됩니다.

|IPv4&nbsp;헤더&nbsp;필드 |목적 |
|---|---|
|***4비트 버전*** |이 필드에는 이 헤더가 나타내는 IP 버전이 포함되어 있습니다. NetX Duo에서 지원하는 IP 버전 4의 경우 이 필드의 값은 4입니다. |
|***4비트 헤더 길이*** |이 필드는 IP 헤더에 있는 32비트 단어 수를 지정합니다. 옵션 단어가 없을 경우 이 필드의 값은 5입니다. |
|***8비트 TOS(서비스 형식)*** |이 필드는 이 IP 패킷에 대해 요청된 서비스 형식을 지정합니다. 유효한 요청은 다음과 같습니다.<br />- 보통: 0x00 <br />- 최소 지연: 0x00<br />- 최대 데이터: 0x08<br />- 최대 안정성: 0x04<br />- 최소 비용: 0x02 |
|***16비트 총 길이*** |이 필드는 IP 헤더를 포함하여 IP 데이터그램의 총 길이(바이트)를 포함합니다. IP 데이터그램은 TCP/IP 인터넷에 있는 기본 정보 단위입니다. 데이터 외에도 대상 및 소스 주소가 포함됩니다. 16비트 필드이기 때문에 IP 데이터그램의 최대 크기는 65,535바이트입니다.|
|***16비트 식별*** |필드는 호스트에서 전송된 각 IP 데이터그램을 고유하게 식별하는 데 사용되는 숫자입니다. 이 숫자는 일반적으로 IP 데이터그램이 전송된 후에 증가합니다. 특히 수신된 IP 패킷 조각을 어셈블하는 데 유용합니다.|
|***3비트 플래그*** |이 필드는 IP 조각화 정보를 포함합니다. 비트 14는 “Don’t Fragment” 비트입니다. 이 비트가 설정되면 나가는 IP 데이터그램이 조각나지 않습니다. 비트 13은 “More Fragments” 비트입니다. 이 비트가 설정되면 더 많은 조각이 생성됩니다. 이 비트가 0이면 이는 IP 패킷의 마지막 조각입니다.|
|***13비트 조각 오프셋*** |이 필드에는 조각 오프셋의 상위 13비트가 포함됩니다. 따라서 조각 오프셋은 8바이트 경계에서만 허용됩니다. 조각화된 IP 데이터그램의 첫 번째 조각은 “More Fragments” 비트 집합을 포함하고 오프셋은 0입니다.|
|***8비트 TTL(Time to Live)*** |이 필드는 데이터그램이 전달할 수 있는 라우터 수를 포함하며, 기본적으로 데이터그램의 수명을 제한합니다.|
|***8비트 프로토콜***|이 필드는 IP 데이터그램을 사용하는 프로토콜을 지정합니다. 다음은 유효한 프로토콜과 프로토콜 값의 목록입니다.<br />- ICMP: 0x01 <br />- IGMP: 0x02<br />- TCP: 0x06<br />- UDP: 0x11 |
|***16비트 체크섬*** |이 필드에는 IP 헤더만 포함하는 16비트 체크섬이 포함됩니다. IP 페이로드를 포함하는 상위 수준 프로토콜에는 추가 체크섬이 있습니다. |
|***32비트 소스 IP 주소*** |이 필드는 항상 호스트 주소이고 보낸 사람의 IP 주소를 포함합니다. |
|***32비트 대상 IP 주소*** |이 필드는 주소가 브로드캐스트 또는 멀티캐스트 주소인 경우 받는 사람 또는 받는 사람의 IP 주소를 포함합니다. |

### <a name="creating-ip-instances"></a>IP 인스턴스 만들기

IP 인스턴스는 초기화 중에 또는 애플리케이션 스레드에서 런타임 중에 만들어집니다. 애플리케이션이 IPv6 네트워크만 사용하려는 경우에도, 내부 IP 스레드의 초기 IPv4 주소, 네트워크 마스크, 기본 패킷 풀, 미디어 드라이버, 메모리 및 우선 순위는 ***nx_ip_create*** 서비스에 의해 정의됩니다. 애플리케이션에서 IPv4 주소를 잘못된 주소(0.0.0.0)로 설정한 IP 인스턴스를 초기화하는 경우 인터페이스 주소는 나중에 RARP를 통한 수동 구성이나 DHCP 또는 유사한 프로토콜을 통해 해결하는 것으로 간주합니다.

여러 네트워크 인터페이스가 있는 시스템의 경우 기본 인터페이스는 ***nx_ip_create** _를 호출할 때 지정됩니다. 각 추가 인터페이스는 _*_nx_ip_interface_attach_**를 호출하여 동일한 IP 인스턴스에 연결할 수 있습니다. 이 서비스는 네트워크 인터페이스(예: IP 주소, 네트워크 마스크)에 대한 정보를 인터페이스 제어 블록에 저장하고 드라이버 인스턴스를 IP 인스턴스의 인터페이스 제어 블록과 연결합니다. 드라이버는 데이터 패킷을 수신할 때 인터페이스 정보를 IP 수신 논리로 전달하기 전에 NX_PACKET 구조에 저장해야 합니다. 인터페이스를 연결하기 전에 IP 인스턴스를 이미 만들어야 합니다.

***nx_ip_create** _를 호출한 후에는 IPv6 서비스가 시작되지 않습니다. IPv6 서비스를 사용하려는 애플리케이션은 _ *_nx_ipv6_enable_** 서비스를 호출하여 IPv6를 시작해야 합니다.

IPv6 네트워크에서는 IP 인스턴스의 각 인터페이스에 여러 IPv6 글로벌 주소가 있을 수 있습니다. 디바이스는 IPv6 주소 할당에 DHCPv6를 사용하는 것 외에도 상태 비저장 주소 자동 구성을 사용할 수 있습니다. 자세한 내용은 이 장의 뒷부분에 나오는 “IP 제어 블록” 및 “IPv6 주소 확인” 섹션에서 확인할 수 있습니다.

### <a name="ip-send"></a>IP 전송

NetX Duo의 IP 전송 처리는 매우 간소화되었습니다. 패킷의 앞에 추가 포인터는 IP 헤더에 맞게 뒤로 이동합니다. IP 헤더가 완료되고(호출 프로토콜 계층에서 지정한 모든 옵션 포함), IP 체크섬이 인라인으로 계산되며(IPv4 패킷 전용), 패킷이 연결된 네트워크 드라이버로 디스패치됩니다. 또한 나가는 조각화도 IP 전송 처리 내에서 조정됩니다.

IPv4의 경우 NetX Duo는 대상 IP 주소에 대한 실제 매핑이 필요한 경우 ARP 요청을 시작합니다. IPv6는 IPv6-address-to-physical-address 매핑에 대한 인접 노드 검색을 사용합니다.

> [!NOTE]
> IPv4 연결의 경우 큐에 있는 패킷 수가 ARP 큐 깊이(**NX_ARP_MAX_QUEUE_DEPTH** 기호에서 정의됨)를 초과할 때까지 IP 주소 확인(실제 매핑)이 필요한 패킷을 ARP 큐에 넣습니다. 큐 깊이에 도달하면 NetX Duo가 큐에서 가장 오래된 패킷을 제거하고 큐에 넣은 나머지 패킷의 주소 확인을 계속 기다립니다. 반면 ARP 항목이 확인되지 않으면 ARP 항목에서 보류 중인 패킷은 ARP 항목 시간 초과 시 해제됩니다.

여러 네트워크 인터페이스를 포함하는 시스템의 경우 NetX Duo는 대상 IP 주소를 기반으로 인터페이스를 선택합니다. 선택 프로세스에 적용되는 프로시저는 다음과 같습니다.

1. 보낸 사람이 나가는 인터페이스를 지정하고 인터페이스가 유효한 경우 해당 인터페이스를 사용합니다.
2. 대상 주소가 IPv4 브로드캐스트 또는 멀티캐스트인 경우 첫 번째 사용 가능한 실제 인터페이스가 사용됩니다.
3. 대상 주소가 고정 라우팅 테이블에 있는 경우 게이트웨이와 연결된 인터페이스가 사용됩니다.
4. 대상이 온-링크인 경우 온-링크 인터페이스가 사용됩니다.
5. 대상 주소가 링크-로컬 주소(169.254.0.0/16)이면 첫 번째 유효한 인터페이스가 사용됩니다.
6. 기본 게이트웨이가 구성된 경우 기본 게이트웨이와 연결된 인터페이스를 사용하여 패킷을 전송합니다.
7. 마지막으로, 유효한 인터페이스 IP 주소 중 하나가 링크-로컬 주소(169.254.0.0/16)인 경우 이 인터페이스는 전송을 위한 소스 주소로 사용됩니다.
8. 위의 모든 작업이 실패하면 출력 패킷이 삭제됩니다.

### <a name="ip-receive"></a>IP 수신

IP 수신 처리는 지연된 수신 패킷 큐에서 패킷을 처리하기 위해 네트워크 드라이버 또는 내부 IP 스레드에서 호출됩니다. IP 수신 처리는 프로토콜 필드를 검사하고 올바른 프로토콜 구성 요소에 대한 패킷의 디스패치를 시도합니다. 패킷이 실제로 디스패치되기 전에 IP 헤더를 지나서 앞에 추가 포인터를 이동하면 IP 헤더가 제거됩니다.

또한 IP 수신 처리는 조각난 IP 패킷을 검색하고, 조각화를 사용하는 경우 조각난 패킷 리어셈블에 필요한 단계를 수행합니다. 조각화가 필요하지만 사용하도록 설정되지 않은 경우 패킷이 삭제됩니다.

NetX Duo는 패킷에 지정된 인터페이스에 따라 적절한 네트워크 인터페이스를 결정합니다. 패킷 인터페이스가 NULL이면 NetX Duo는 기본 인터페이스로 기본 설정됩니다. 이는 레거시 NetX Duo 이더넷 드라이버와의 호환성을 보장하기 위해 수행됩니다.

### <a name="raw-ip-send"></a>원시 IP 전송

원시 IP 패킷은 NetX Duo에서 직접 지원하고 처리하지 않는 상위 계층 프로토콜 페이로드를 포함하는 IP 프레임입니다. 원시 패킷을 통해 개발자는 자신의 IP 기반 애플리케이션을 정의할 수 있습니다. _*_nx_ip_raw_packet_enabled_*_ 서비스에서 원시 IP 패킷 처리를 사용하도록 설정한 경우 애플리케이션은 ***nxd_ip_raw_packet_send** _ 서비스를 사용하여 원시 IP 패킷을 직접 전송할 수 있습니다. IPv6 네트워크에서 유니캐스트 패킷을 전송하는 경우 NetX Duo는 대상 주소를 기반으로 패킷을 전송하기 위해 사용할 최적의 소스 IPv6 주소를 자동으로 결정합니다. 그러나 대상 주소가 멀티캐스트(또는 IPv4의 경우 브로드캐스트) 주소인 경우 NetX Duo는 첫 번째 기본 인터페이스로 기본 설정됩니다. 따라서 보조 인터페이스에서 이러한 패킷을 전송하려면 애플리케이션이 _ *_nx_ip_raw_packet_source_send_** 서비스를 사용하여 나가는 패킷에 사용할 소스 주소를 지정해야 합니다.

### <a name="raw-ip-receive"></a>원시 IP 수신

원시 IP 패킷 처리를 사용하는 경우 애플리케이션은 ***nx_ip_raw_packet_receive** _ 서비스를 통해 원시 IP 패킷을 받을 수 있습니다. 들어오는 모든 패킷은 IP 헤더에 지정된 프로토콜에 따라 처리됩니다. 프로토콜이 UDP, TCP, IGMP, ICMP를 지정하는 경우 NetX Duo는 패킷 프로토콜 형식에 적합한 처리기를 사용하여 패킷을 처리합니다. 프로토콜이 이러한 프로토콜 중 하나가 아니며 원시 IP 수신을 사용하도록 설정한 경우 들어오는 패킷은 _*_nx_ip_raw_packet_receive_** 서비스를 통해 애플리케이션이 수신되기를 대기하는 원시 패킷 큐에 배치됩니다. 또한 애플리케이션 스레드는 원시 IP 패킷을 기다리는 동안 선택적 시간 제한으로 일시 중단될 수 있습니다. 원시 패킷 큐에서 큐에 대기할 수 있는 패킷 수는 제한되어 있습니다. 최댓값은 ***NX_IP_RAW_MAX_QUEUE_DEPTH**_ 에 정의되고 기본값은 20입니다. 애플리케이션은 _ *_nx_ip_raw_receive_queue_max_set_** 서비스를 호출하여 최댓값을 변경할 수 있습니다.

또는 ***NX_ENABLE_IP_RAW_PACKET_FILTER*.** 를 사용하여 NetX Duo 라이브러리를 빌드할 수 있습니다. 이 작업 모드에서 애플리케이션은 처리되지 않은 프로토콜 형식의 패킷을 수신할 때마다 호출되는 콜백 함수를 제공합니다. IP 수신 논리는 패킷을 사용자 정의 원시 패킷 수신 필터 루틴으로 전달합니다. 필터 루틴은 이후 프로세스를 위해 원시 패킷을 유지할지 여부를 결정합니다. 콜백 루틴의 반환 값은 패킷이 원시 패킷 수신 필터에 의해 처리되었는지 여부를 나타냅니다. 패킷이 콜백 함수에 의해 처리되는 경우 애플리케이션이 패킷을 사용한 후에 패킷을 해제해야 합니다. 그러지 않으면 NetX Duo가 패킷을 릴리스합니다. 원시 패킷 필터 함수를 사용하는 방법에 대한 자세한 내용은 **_nx_ip_raw_packet_filter_set_** 을 참조하세요.

> [!NOTE]
> *NetX Duo의 BSD 래퍼 기능은 원시 패킷 필터 함수를 사용하여 BSD 원시 소켓을 처리합니다. 따라서 BSD 래퍼의 원시 소켓을 지원하려면 ***NX_ENABLE_IP_RAW_PACKET_FILTER** _ 정의를 사용하여 NetX Duo 라이브러리를 빌드해야 하며 애플리케이션은 _*_nx_ip_raw_packet_filter_set_*_ 을 사용하여 자체 원시 패킷 필터 함수를 설치하지 않아야 합니다.

### <a name="default-packet-pool"></a>기본 패킷 풀

각 IP 인스턴스에는 만드는 동안 기본 패킷 풀이 지정됩니다. 이 패킷 풀은 ARP, RARP, ICMP, IGMP, 다양한 TCP 제어 패킷(SYN, ACK 등), 인접 노드 검색, 라우터 검색, 중복 주소 검색에 대한 패킷을 할당하는 데 사용됩니다. NetX Duo에서 패킷을 할당해야 할 때 기본 패킷 풀이 비어 있으면 NetX Duo가 특정 작업을 중단해야 할 수 있으며 가능한 경우 오류 메시지를 반환합니다.

### <a name="ip-helper-thread"></a>IP 도우미 스레드

각 IP 인스턴스에는 도우미 스레드가 있습니다. 이 스레드는 모든 지연된 패킷 처리 및 모든 주기적 처리를 담당합니다. IP 도우미 스레드는 ***nx_ip_create*** 에서 만들어집니다. 여기서 스레드의 스택 및 우선 순위를 지정합니다. IP 도우미 스레드의 첫 번째 처리 작업은 IP 만들기 서비스와 연결된 네트워크 드라이버 초기화를 완료하는 것입니다. 네트워크 드라이버 초기화가 완료되면 도우미 스레드는 패킷 및 주기적 요청을 처리하기 위해 무한 루프를 시작합니다.

> [!IMPORTANT]
> IP 도우미 스레드에서 설명할 수 없는 동작이 나타나는 경우, IP 만들기 서비스 중에 스택 크기를 늘리는 것이 첫 번째 디버깅 단계입니다. 스택이 너무 작으면 IP 도우미 스레드가 메모리를 덮어쓸 수 있으며 이로 인해 비정상적인 문제가 발생할 수 있습니다.

### <a name="thread-suspension"></a>스레드 일시 중단

애플리케이션 스레드는 원시 IP 패킷을 수신하는 동안 일시 중단될 수 있습니다. 원시 패킷이 수신되면 새 패킷이 일시 중단된 첫 번째 스레드에 제공되고 해당 스레드가 다시 시작됩니다. 패킷을 수신하는 NetX Duo 서비스에는 모두 선택적 일시 중단 시간 제한이 있습니다. 패킷을 수신하거나 시간 제한이 만료되면 애플리케이션 스레드가 적절한 완료 상태로 다시 시작됩니다.

### <a name="ip-statistics-and-errors"></a>IP 통계 및 오류

사용하도록 설정된 경우 NetX Duo는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다. 각 IP 인스턴스에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.

- 전송된 총 IP 패킷
- 전송된 총 IP 바이트
- 수신된 총 IP 패킷
- 수신된 총 IP 바이트
- 총 IP 잘못된 패킷
- 삭제된 총 IP 수신 패킷
- 총 IP 수신 체크섬 오류
- 삭제된 총 IP 전송 패킷
- 전송된 총 IP 조각
- 수신된 총 IP 조각

이러한 모든 통계 및 오류 보고서는 ***nx_ip_info_get*** 서비스를 사용하여 애플리케이션에서 사용할 수 있습니다.

### <a name="ip-control-block-nx_ip"></a>IP 제어 블록 NX_IP

각 IP 인스턴스의 특성은 해당 제어 블록에서 확인할 수 있습니다. 각 네트워크 디바이스의 IP 주소 및 네트워크 마스크, 인접 IP 및 실제 하드웨어 주소 매핑 테이블과 같은 유용한 정보를 포함합니다. 이 구조는 ***nx_api.h** 파일에 정의됩니다. IPv6를 사용하도록 설정한 경우 사용자가 구성할 수 있는 옵션 _*_NX_MAX_IPV6_ADDRESSES_**로 지정된 수의 IPv6 주소 배열을 포함합니다. 기본값을 사용하면 각 실제 네트워크 인터페이스에 세 개의 IPv6 주소를 포함할 수 있습니다.

IP 인스턴스 제어 블록은 메모리의 어디에나 위치할 수 있지만 제어 블록을 모든 함수의 범위 밖에 정의하여 전역 구조로 만드는 것이 가장 일반적입니다.

### <a name="static-ipv4-routing"></a>고정 IPv4 라우팅

고정 라우팅 기능을 사용하면 애플리케이션에서 특정 네트워크 외부 대상 IP 주소에 대해 IPv4 네트워크 및 다음 홉 주소를 지정할 수 있습니다. 고정 라우팅을 사용하도록 설정한 경우 NetX Duo는 고정 라우팅 테이블을 통해 전송할 패킷의 대상 주소와 일치하는 항목을 검색합니다. 일치하는 항목이 없으면 NetX Duo는 실제 인터페이스 목록을 검색하여 대상 IP 주소와 네트워크 마스크를 기반으로 소스 IP 주소와 다음 홉 주소를 선택합니다. 대상이 IP 인스턴스에 연결된 네트워크 드라이버의 IP 주소와 일치하지 않으면 NetX Duo는 기본 게이트웨이에 직접 연결된 인터페이스를 선택하고 인터페이스의 IP 주소를 소스 주소로 사용하고 기본 게이트웨이를 다음 홉으로 사용합니다.

각각 ***nx_ip_static_route_add** _ 및 _ *_nx_ip_static_route_delete_** 서비스를 사용하여 고정 라우팅 테이블에서 항목을 추가하고 제거할 수 있습니다. 고정 라우팅을 사용하려면 호스트 애플리케이션이 ***NX_ENABLE_IP_STATIC_ROUTING*** 을 정의하여 이 기능을 사용하도록 설정해야 합니다.

> [!NOTE]
> 고정 라우팅 테이블에 항목을 추가하는 경우 NetX Duo는 테이블에 이미 있는 지정된 대상 주소와 일치하는 항목을 확인합니다. 항목이 있는 경우 네트워크 마스크에서 더 작은 네트워크(더 긴 접두사)가 있는 항목을 선호합니다.

### <a name="ipv4-forwarding"></a>IPv4 전달

들어오는 IPv4 패킷이 이 노드에 적합하지 않고 IPv4 전달 기능이 사용되도록 설정된 경우 NetX Duo는 다른 인터페이스를 통해 패킷을 전달하려고 합니다.  

### <a name="ip-fragmentation"></a>IP 조각화

네트워크 디바이스에는 나가는 패킷의 크기가 제한될 수 있습니다. 이 제한을 MTU(최대 전송 단위)라고 합니다. IP MTU는 링크 계층 드라이버가 IP 패킷을 조각화하지 않고 전송할 수 있는 가장 큰 IP 프레임 크기입니다. 디바이스 드라이버 초기화 단계에서 드라이버 모듈은 ***nx_ip_interface_mtu_set*** 서비스를 통해 IP MTU 크기를 구성해야 합니다.

권장하지는 않지만 애플리케이션은 디바이스에서 지원되는 기본 IP MTU보다 큰 데이터그램을 생성할 수 있습니다. 이와 같은 IP 데이터그램을 전송하기 전에 IP 계층은 이러한 패킷을 분할해야 합니다. 조각난 IP 프레임을 수신하는 경우, 수신 끝은 조각난 모든 IP 프레임을 동일한 조각화 ID로 저장하고 순서대로 리어셈블해야 합니다. IP 수신 논리가 모든 조각을 수집하여 원래 IP 프레임을 제때 복원할 수 없는 경우 모든 조각이 해제됩니다. 이러한 패킷 손실을 탐지하고 그로부터 복구하는 것은 상위 계층 프로토콜의 역할입니다.

IP 조각화는 IPv4와 IPv6 패킷 모두에 적용됩니다.

IP 조각화 및 리어셈블리 작업을 지원하기 위해 시스템 디자이너는 ***nx_ip_fragment_enable*** 서비스를 사용하여 NetX Duo에서 IP 조각화 기능을 사용하도록 설정해야 합니다. 이 기능을 사용하도록 설정하지 않으면 네트워크 드라이버의 MTU를 초과하는 패킷뿐만 아니라 들어오는 조각난 IP 패킷도 삭제됩니다.

> [!NOTE]
> NetX Duo 라이브러리를 빌드할 때 ***NX_DISABLE_FRAGMENTATION** _을 정의하여 IP 조각화 논리를 완전히 제거할 수 있습니다. 이렇게 하면 NetX Duo의 코드 크기를 줄일 수 있습니다. 이 경우 IPv4 및 IPv6 조각화/리어셈블리 함수는 모두 사용할 수 없습니다.

> [!NOTE]
> **NX_DISABLE_CHAINED_PACKET** 이 정의된 경우 IP 조각화를 사용하지 않도록 설정해야 합니다.

> [!NOTE]
> IPv6 네트워크에서 라우터는 데이터그램의 크기가 최소 MTU 크기를 초과할 경우 데이터그램을 조각내지 않습니다. 따라서 소스와 대상 간의 최소 MTU를 결정하고 IP 데이터그램 크기가 경로 MTU를 초과하지 않도록 하는 것은 전송 디바이스의 역할입니다. NetX Duo에서 정의된 **NX_ENABLE_IPV6_PATH_MTU_DISCOVERY** 기호가 있는 NetX Duo 라이브러리를 빌드하여 IPv6 PATH MTU 검색을 사용하도록 설정할 수 있습니다.

## <a name="address-resolution-protocol-arp-in-ipv4"></a>IPv4의 ARP(주소 확인 프로토콜)

ARP(주소 확인 프로토콜)는 32비트 IPv4 주소를 기본 실제 미디어(RFC 826)의 주소에 동적으로 매핑하는 역할을 합니다. 이더넷은 가장 일반적인 실제 미디어이며 48비트 주소를 지원합니다. ARP의 필요성은 ***nx_ip_create** _ 서비스에 제공된 네트워크 드라이버에 의해 결정됩니다. 실제 매핑이 필요한 경우 네트워크 드라이버에서 _ *_nx_interface_address_mapping_needed_** 서비스를 사용하여 드라이버 인터페이스를 올바르게 구성해야 합니다.

### <a name="arp-enable"></a>ARP 사용

ARP가 제대로 작동하려면 먼저 애플리케이션이 ***nx_arp_enable*** 서비스를 사용하도록 설정해야 합니다. 이 서비스는 ARP 사용 서비스에 제공된 메모리에서 ARP 캐시 영역을 만드는 등 ARP 처리를 위한 다양한 데이터 구조를 설정합니다.

### <a name="arp-cache"></a>ARP 캐시

ARP 캐시는 내부 ARP 매핑 데이터 구조의 배열로 볼 수 있습니다. 각 내부 구조는 IP 주소와 실제 하드웨어 주소 사이의 관계를 유지 관리할 수 있습니다. 또한 각 데이터 구조에는 링크 포인터가 있어 여러 연결된 목록에 포함될 수 있습니다.

매핑이 ARP 테이블에 있는 경우 애플리케이션은 ***nx_arp_ip_address_find** _ 서비스를 사용하여 하드웨어 MAC 주소를 제공하는 방법으로 ARP 캐시에서 IP 주소를 조회할 수 있습니다. 마찬가지로 _ _nx_arp_hardware_address_find_* 서비스는 지정된 IP 주소에 대한 MAC 주소를 반환합니다.

### <a name="arp-dynamic-entries"></a>ARP 동적 항목

기본적으로 ARP 사용 서비스는 ARP 캐시의 모든 항목을 사용 가능한 동적 ARP 항목 목록에 배치합니다. 매핑되지 않은 IP 주소에 대한 전송 요청이 검색되면 이 목록에서 NetX Duo가 동적 ARP 항목을 할당합니다. 할당 후 ARP 항목이 설정되고 실제 미디어로 ARP 요청이 전송됩니다.

***nx_arp_dynamic_entry_set*** 서비스에서 동적 항목을 만들 수도 있습니다.

> [!IMPORTANT]
> 모든 동적 ARP 항목이 사용 중인 경우 오래전에 사용한 ARP 항목이 새 매핑으로 바뀝니다.

### <a name="arp-static-entries"></a>ARP 고정 항목

또한 애플리케이션은 ***nx_arp_static_entry_create** _ 서비스를 사용하여 고정 ARP 매핑을 설정할 수 있습니다. 이 서비스는 동적 ARP 항목 목록에서 ARP 항목을 할당하고 애플리케이션에서 제공하는 매핑 정보와 함께 고정 목록에 배치합니다. 고정 ARP 항목에는 재사용 또는 에이징이 적용되지 않습니다. 애플리케이션은 서비스 _*_nx_arp_static_entry_delete_*_ 를 사용하여 고정 항목을 삭제할 수 있습니다. ARP 테이블의 모든 고정 항목을 제거하기 위해 애플리케이션은 _*_nx_arp_static_entries_delete_** 서비스를 사용할 수 있습니다.

### <a name="automatic-arp-entry"></a>자동 ARP 항목

NetX Duo는 ARP 요청에 대한 피어 응답 후 피어의 IP/MAC 매핑을 기록합니다. NetX Duo는 또한 네트워크에서 요청되지 않은 ARP 요청을 기반으로 피어 IP/MAC 주소 매핑을 기록하는 자동 ARP 항목 기능을 구현합니다. 이 기능을 사용하면 ARP 테이블을 피어 정보로 채울 수 있으므로 ARP 요청/응답 주기를 통과하는 데 필요한 지연을 줄일 수 있습니다. 그러나 자동 ARP를 사용하는 경우의 단점은 ARP 테이블이 로컬 링크에 많은 노드가 있는 사용량이 많은 네트워크에서 빠르게 채워지는 경향이 있고, 결국 이로 인해 ARP 항목을 대체하게 된다는 것입니다.

이 기능은 기본적으로 사용하도록 설정됩니다. 이 기능을 사용하지 않으려면 정의된 ***NX_DISABLE_ARP_AUTO_ENTRY*** 기호를 사용하여 NetX Duo 라이브러리를 컴파일해야 합니다.</p>

### <a name="arp-messages"></a>ARP 메시지

앞에서 언급한 대로 IP 작업에서 IP 주소에 대한 매핑이 필요하다는 것을 감지하면 ARP 요청 메시지가 전송됩니다. ARP 요청은 해당 ARP 응답이 수신될 때까지 주기적으로(매 ***NX_ARP_UPDATE_RATE** _초마다) 전송됩니다. ARP 시도가 중단되기 전에 총 _ *_NX_ARP_MAXIMUM_RETRIES_** ARP 요청이 수행됩니다. ARP 응답이 수신되면 관련된 물리적 주소 정보는 캐시에 있는 ARP 항목에 저장됩니다.

멀티홈 시스템의 경우 NetX Duo는 지정된 대상 주소에 따라 ARP 요청 및 응답을 보낼 인터페이스를 결정합니다.

> [!NOTE]
> NetX Duo가 ARP 응답을 대기하는 동안 나가는 IP 패킷은 큐에 대기합니다. 큐에 있는 나가는 IP 패킷 수는 상수 **NX_ARP_MAX_QUEUE_DEPTH** 에 의해 정의됩니다.

NetX Duo는 로컬 IPv4 네트워크에 있는 다른 노드의 ARP 요청에도 응답합니다. ARP 요청을 수신하는 인터페이스의 현재 IP 주소와 일치하는 외부 ARP 요청이 이루어지면 NetX Duo는 현재 물리적 주소를 포함하는 ARP 응답 메시지를 작성합니다.

이더넷 ARP 요청 및 응답의 형식은 그림 6에 나타나 있으며 아래에 설명되어 있습니다.

| **요청/응답&nbsp;필드**         | **용도**            |
| ---------------------------------- | ---------------------- |
| ***이더넷 대상 주소*** | 이 6바이트 필드는 ARP 응답의 대상 주소를 포함하며 ARP 요청을 위한 브로드캐스트(모두 포함)입니다. 이 필드는 네트워크 드라이버에 의해 설정됩니다. 
| ***이더넷 소스 주소***      | 이 6바이트 필드는 ARP 요청 또는 응답의 보낸 사람 주소를 포함하고 네트워크 드라이버에 의해 설정됩니다. |
| ***프레임 형식*** | 이 2바이트 필드는 표시되는 이더넷 프레임 형식을 포함하며, ARP 요청 및 응답의 경우 이는 0x0806과 같습니다. 네트워크 드라이버가 설정할 마지막 필드입니다. |
| ***하드웨어 종류*** | 이 2바이트 필드에는 이더넷에 대해 0x0001인 하드웨어 종류가 포함됩니다. |
| ***프로토콜 형식*** | 이 2바이트 필드에는 IP 주소에 대해 0x0800인 프로토콜 형식이 포함됩니다. |
| ***하드웨어 크기*** | 이 1바이트 필드에는 이더넷 주소에 대해 6인 하드웨어 주소 크기가 포함됩니다. |

![ARP 패킷 형식의 다이어그램입니다.](./media/user-guide/arp-packet-format.png)

**그림 6. ARP 패킷 형식**

| 요청/응답&nbsp;필드 | 목적 |
|---|---|
| ***프로토콜 크기*** | 이 1바이트 필드에는 IP 주소에 대해 4인 IP 주소 크기가 포함됩니다. |
| ***작업 코드*** | 이 2바이트 필드에는 이 ARP 패킷에 대한 작업이 포함됩니다. ARP 요청은 0x0001 값으로 지정되고, ARP 응답은 0x0002 값으로 표시됩니다. |
| ***보낸 사람 이더넷 주소*** | 이 6바이트 필드에는 보낸 사람의 이더넷 주소가 포함됩니다. |
| ***보낸 사람 IP 주소*** | 이 4바이트 필드에는 보낸 사람의 IP 주소가 포함됩니다. |
| ***대상 이더넷 주소*** | 이 6바이트 필드에는 대상의 이더넷 주소가 포함됩니다. |
| ***대상 IP 주소*** | 이 4바이트 필드에는 대상의 IP 주소가 포함됩니다. |

> [!NOTE]
> ARP 요청 및 응답은 이더넷 수준 패킷입니다. 다른 모든 TCP/IP 패킷은 IP 패킷 헤더에서 캡슐화됩니다.

> [!NOTE]
> TCP/IP 구현의 모든 ARP 메시지는 **big endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.

### <a name="arp-aging"></a>ARP 에이징

NetX는 자동 동적 ARP 항목 무효화를 지원합니다. ***NX_ARP_EXPIRATION_RATE** _는 실제 매핑에 대해 설정된 IP 주소가 유효한 상태로 유지되는 시간(초)을 지정합니다. 만료 후 ARP 항목은 ARP 캐시에서 제거됩니다. 다음번에 해당 IP 주소로 전송하려고 하면 새 ARP 요청이 발생합니다. _ *_NX_ARP_EXPIRATION_RATE_**를 0으로 설정하면 기본 구성인 ARP 에이징을 사용하지 않게 됩니다.

### <a name="arp-defend"></a>ARP 방어

ARP 요청 또는 ARP 응답 패킷이 수신되고 보낸 사람이 이 노드의 IP 주소와 충돌하는 동일한 IP 주소를 가질 때 NetX Duo는 해당 주소에 대한 ARP 요청을 방어 수단으로 전송합니다. 충돌 ARP 패킷이 10초 이내에 두 번 이상 수신되면 NetX Duo는 더 이상 방어 패킷을 전송하지 않습니다. 기본 간격 10초는 ***NX_ARP_DEFEND_INTERVAL** _로 다시 정의할 수 있습니다. 이 동작은 RFC5227의 2.4(c)에 지정된 정책을 따릅니다. Windows XP에서는 ARP 프로브를 위한 응답으로 ARP 알림을 무시하기 때문에 사용자가 _ *_NX_ARP_DEFEND_BY_REPLY_**를 정의하여 ARP 응답을 추가 방어 수단으로 전송할 수 있습니다.

### <a name="arp-statistics-and-errors"></a>ARP 통계 및 오류

사용하도록 설정된 경우 NetX Duo ARP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다. 각 IP의 ARP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.

- 전송된 총 ARP 요청
- 수신된 총 ARP 요청
- 전송된 총 ARP 응답 
- 수신된 총 ARP 응답 
- 총 ARP 동적 항목 
- 총 ARP 고정 항목 
- 총 ARP 오래된 항목 
- 총 ARP 잘못된 메시지 

이러한 모든 통계 및 오류 보고서는 애플리케이션이 ***nx_arp_info_get*** 서비스를 사용하여 이용할 수 있습니다.

## <a name="reverse-address-resolution-protocol-rarp-in-ipv4"></a>IPv4의 RARP(역주소 확인 프로토콜)

RARP(역주소 확인 프로토콜)는 호스트의 32비트 IP 주소(RFC 903)에 대한 네트워크 할당을 요청하는 프로토콜입니다. 이 작업은 RARP 요청을 통해 수행되며 네트워크 멤버가 RARP 응답에서 호스트 네트워크 인터페이스에 IP 주소를 할당할 때까지 주기적으로 계속됩니다. 애플리케이션은 IP 주소가 0인 ***nx_ip_create*** 서비스에서 IP 인스턴스를 만듭니다. 애플리케이션에서 RARP를 사용하는 경우 RARP 프로토콜을 사용하여 IP 주소가 0인 인터페이스를 통해 액세스할 수 있는 네트워크 서버에서 IP 주소를 요청할 수 있습니다.

### <a name="rarp-enable"></a>RARP 사용

RARP를 사용하려면 애플리케이션에서 IP 주소가 0인 IP 인스턴스를 만든 다음, ***nx_rarp_enable*** 서비스를 사용하여 RARP를 사용하도록 설정해야 합니다. 멀티홈 시스템의 경우 IP 인스턴스와 연결된 하나 이상의 네트워크 디바이스에 0인 IP 주소가 있어야 합니다. RARP 처리는 네트워크 지정 IP 주소를 사용하는 유효한 RARP 응답이 수신될 때까지 IP 주소가 필요한 NetX Duo 시스템에 대한 RARP 요청 메시지를 주기적으로 전송합니다. 이때 RARP 처리가 완료됩니다.

RARP를 사용하도록 설정한 후에는 모든 인터페이스 주소가 확인되면 자동으로 사용할 수 없게 됩니다. 애플리케이션이 ***nx_rarp_disable*** 서비스를 사용하여 강제로 RARP를 종료할 수 있습니다.

### <a name="rarp-request"></a>RARP 요청

RARP 요청 패킷의 형식은 [그림 6](#arp-messages)에 표시된 ARP 패킷과 거의 동일합니다. 유일한 차이점은 프레임 유형 필드는 0x8035이고 ‘작업 코드’ 필드는 3이며 RARP 요청을 지정한다는 것입니다. 앞에서 언급한 대로 RARP 요청은 네트워크에서 할당된 IP 주소를 가진 RARP 회신이 수신될 때까지 주기적으로(매 ***NX_RARP_UPDATE_RATE*** 초마다) 전송됩니다.

> [!NOTE]
> TCP/IP 구현의 모든 RARP 메시지는 **big endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.

### <a name="rarp-reply"></a>RARP 응답

RARP 응답 메시지는 네트워크에서 수신되고 이 호스트에 할당된 네트워크 IP 주소를 포함합니다. RARP 응답 패킷의 형식은 그림 6에 표시된 ARP 패킷과 거의 동일합니다. 유일한 차이점은 프레임 유형 필드는 0x8035이고 ‘작업 코드’ 필드는 4이며 RARP 응답을 지정하는 것입니다. 수신 후 IP 주소는 IP 인스턴스에서 설정되고 주기적 RARP 요청은 사용할 수 없으며 IP 인스턴스는 정상적인 네트워크 작업을 수행할 준비가 되었습니다.

멀티홈 호스트의 경우 IP 주소가 요청 네트워크 인터페이스에 적용됩니다. 여전히 IP 주소 할당을 요청하는 다른 네트워크 인터페이스가 있는 경우 모든 인터페이스 IP 주소 요청이 해결될 때까지 주기적인 RARP 서비스는 계속됩니다.

> [!NOTE]
> 애플리케이션은 RARP 처리가 완료될 때까지 IP 인스턴스를 사용하면 안 됩니다. **nx_ip_status_check** 를 사용하여 애플리케이션에서 RARP 완료를 기다릴 수 있습니다. 멀티홈 시스템의 경우 애플리케이션은 해당 인터페이스에서 RARP 처리가 완료될 때까지 요청 인터페이스를 사용하지 않아야 합니다. **nx_ip_interface_status_check** 서비스를 사용하여 보조 디바이스의 IP 주소 상태를 확인할 수 있습니다.

### <a name="rarp-statistics-and-errors"></a>RARP 통계 및 오류

사용하도록 설정된 경우 NetX Duo RARP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다. 각 IP의 RARP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.

- 전송된 총 RARP 요청
- 수신된 총 RARP 응답
- 총 RARP 잘못된 메시지

이러한 모든 통계 및 오류 보고서는 애플리케이션에서 ***nx_rarp_info_get*** 서비스를 통해 사용할 수 있습니다.

## <a name="internet-control-message-protocol-icmp"></a>ICMP(Internet Control Message Protocol)

IPv4용 ICMP(Internet Control Message Protocol)는 IP 네트워크 멤버 사이에서 오류 및 제어 정보를 전달만 합니다. ICMPv6(IPv6용 Internet Control Message Protocol)도 오류 및 제어 정보를 처리하며 DAD(중복 주소 검색) 및 상태 비저장 주소 자동 구성과 같은 주소 확인 프로토콜에 필요합니다.

대부분의 다른 애플리케이션 계층(예: TCP/IP) 메시지와 마찬가지로 ICMP 및 ICMPv6 메시지는 ICMP(또는 ICMPv6) 프로토콜이 지정된 IP 헤더에 의해 캡슐화됩니다.

### <a name="icmp-statistics-and-errors"></a>ICMP 통계 및 오류

사용하도록 설정된 경우 NetX Duo는 애플리케이션에 유용할 수 있는 몇 가지 ICMP 통계 및 오류를 추적합니다. 각 IP의 ICMP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다. 

- 전송된 총 ICMP Ping  
- 총 ICMP Ping 시간 제한 
- 일시 중단된 총 ICMP Ping 스레드 
- 수신된 총 ICMP Ping 응답 
- 총 ICMP 체크섬 오류 
- 총 ICMP 처리되지 않은 메시지 

이러한 모든 통계 및 오류 보고서는 애플리케이션이 ***nx_icmp_info_get*** 서비스를 사용하여 이용할 수 있습니다.

## <a name="icmpv4-services-in-netx-duo"></a>NetX Duo의 ICMPv4 서비스

### <a name="icmpv4-enable"></a>ICMPv4 사용

NetX Duo에서 ICMPv4 메시지를 처리하려면 먼저 애플리케이션이 ***nx_icmp_enable*** 서비스를 호출하여 ICMPv4를 처리하도록 설정해야 합니다. 이 작업이 완료되면 애플리케이션에서 Ping 요청을 실행하고 들어오는 Ping 패킷을 처리할 수 있습니다.  

### <a name="icmpv4-echo-request"></a>ICMPv4 에코 요청

에코 요청은 호스트 IP 주소로 식별되는 네트워크에 특정 노드가 있는지 확인하는 데 일반적으로 사용되는 ICMPv4 메시지의 한 유형입니다. 인기 있는 ping 명령은 ICMP 에코 요청/에코 응답 메시지를 사용하여 구현됩니다. 특정 호스트가 있는 경우 해당 네트워크 스택은 Ping 요청 및 응답을 ping 응답으로 처리합니다. 그림 7에서는 ICMPv4 Ping 메시지 형식에 대해 자세히 나타냅니다.

![ICMPv4 Ping 메시지](./media/user-guide/icmpv4-ping-message.png)  

**그림 7. ICMPv4 Ping 메시지**

> [!NOTE]
> TCP/IP 구현의 모든 ICMPv4 메시지는 **Big Endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.

다음은 ICMPv4 헤더 형식에 대한 설명입니다.

|헤더 필드 |목적 |
|---|---|
|**형식** |이 필드에서는 ICMPv4 메시지(31-24비트)를 지정합니다. 가장 일반적인 메시지:<br />- 0: 에코 응답<br />- 3: 대상에 연결할 수 없음<br />- 8: 에코 요청<br />- 11: 시간 초과<br />- 12: 매개 변수 문제 |
|‘코드’ |이 필드는 형식 필드의 컨텍스트에 따라 값이 달라집니다(23-16비트). 에코 요청 또는 응답의 경우 코드는 0으로 설정됩니다.|
|**Checksum** |이 필드는 형식 필드에서 시작하는 ICMPv4 헤더 전체를 포함하여 ICMPv4 메시지의 1의 보수 합계에 대한 16비트 체크섬을 포함합니다. 체크섬을 생성하기 전에 체크섬 필드가 지워집니다.|
|**ID** | 이 필드는 호스트를 식별하는 ID 값을 포함합니다. 호스트는 에코 응답의 에코 요청에서 추출된 ID를 사용해야 합니다(31-16비트).|
|**시퀀스 번호** |이 필드는 ID 값을 포함합니다. 호스트는 에코 응답의 에코 요청에서 추출된 ID를 사용해야 합니다(31-16비트). ID 필드와 달리 이 값은 동일한 호스트의 후속 에코 요청에서 변경됩니다(15-0비트).|

### <a name="icmpv4-echo-response"></a>ICMPv4 에코 응답    
ping 응답은 외부 ping 요청에 대한 응답으로 ICMP 구성 요소에 의해 내부적으로 생성되는 또 다른 형식의 ICMP 메시지입니다. ping 응답에는 승인 외에, ping 요청에 제공된 사용자 데이터 복사본도 포함됩니다.

### <a name="icmpv4-error-messages"></a>ICMPv4 오류 메시지   
다음 ICMPv4 오류 메시지는 NetX Duo에서 지원됩니다. 
- 대상에 연결할 수 없음 
- 시간 초과 
- 매개 변수 문제

## <a name="internet-group-management-protocol-igmp"></a>IGMP(Internet Group Management Protocol)

IGMP(Internet Group Management Protocol)는 IPv4 멀티캐스트 그룹(RFC 1112와 RFC 2236)을 수신하거나 가입하려는 인접 노드 및 라우터와 통신할 수 있는 디바이스를 제공합니다. 멀티캐스트 그룹은 기본적으로 네트워크 멤버의 동적 집합이며 클래스 D IP 주소로 표시됩니다. 멀티캐스트 그룹의 멤버는 언제든지 탈퇴할 수 있고, 새로운 멤버는 언제든지 가입할 수 있습니다. 그룹에 가입하고 탈퇴하는 것과 관련된 조정은 IGMP에서 수행해야 합니다.

> [!NOTE]
> IGMP는 IPv4 멀티캐스트 그룹만을 위해 설계되었습니다. IPv6 네트워크에서는 사용할 수 없습니다.

### <a name="igmp-enable"></a>IGMP 사용     
NetX Duo에서 멀티캐스팅 작업을 수행하려면 먼저 애플리케이션이 ***nx_igmp_enable*** 서비스를 호출해야 합니다. 이 서비스는 멀티캐스트 요청에 준비하기 위해 기본적인 IGMP 초기화를 수행합니다.

### <a name="multicast-ipv4-addressing"></a>멀티캐스트 IPv4 주소 지정  
앞에서 설명한 대로 멀티캐스트 주소는 실제 [그림 4](#ipv4-addresses)에 나와 있는 것처럼 클래스 D IP 주소입니다. 클래스 D 주소의 하위 28비트는 멀티캐스트 그룹 ID에 해당합니다. 미리 정의된 일련의 멀티캐스트 주소가 있습니다. 그러나 ‘모든 호스트 주소’(244.0.0.1)는 IGMP 처리에 특히 중요합니다. ‘모든 호스트 주소’는 라우터가 모든 멀티캐스트 멤버를 쿼리하여 자신이 속한 멀티캐스트 그룹을 보고하는 데 사용됩니다.  

### <a name="physical-address-mapping-in-ipv4"></a>IPv4의 물리적 주소 매핑
클래스 D 멀티캐스트 주소는 01.00.5e.00.00.00에서 01.00.5e.7f.ff.ff까지 범위의 실제 이더넷 주소로 직접 매핑됩니다. IP 멀티캐스트 주소의 하단 23비트는 이더넷 주소의 하위 23비트에 직접 매핑됩니다.

### <a name="multicast-group-join"></a>멀티캐스트 그룹 가입
특정 멀티캐스트 그룹에 가입해야 하는 애플리케이션은 ***nx_igmp_multicast_join*** 서비스를 호출하여 이 작업을 수행할 수 있습니다. 이 서비스는 이 멀티캐스트 그룹에 가입하려는 요청 수를 추적합니다. 멀티캐스트 그룹에 가입하려는 첫 번째 애플리케이션 요청이라면 IGMP 보고서는 그룹에 가입하려는 이 호스트의 의도를 나타내는 기본 네트워크에 전송됩니다. 그런 다음 네트워크 드라이버를 호출하여 이 멀티캐스트 그룹에 대한 이더넷 주소로 패킷을 수신 대기하도록 설정합니다.

멀티홈 시스템에서, 멀티캐스트 그룹이 특정 인터페이스를 통해 접근할 수 있다면, 애플리케이션은 기본 네트워크의 멀티캐스트 그룹으로 제한된 _*_nx_igmp_multicast_join_** 대신 ***nx_igmp_multicast_interface_join** _ 서비스를 사용해야 합니다.

### <a name="multicast-group-leave"></a>멀티캐스트 그룹 탈퇴   
이전에 가입된 멀티캐스트 그룹을 탈퇴해야 하는 애플리케이션은 ***nx_igmp_multicast_leave*** 서비스를 호출하여 탈퇴할 수 있습니다. 이 서비스는 그룹이 가입된 횟수와 관련된 내부 횟수를 줄입니다. 그룹에 처리 중인 가입 요청이 없는 경우 네트워크 드라이버를 호출하여 이 멀티캐스트 그룹의 이더넷 주소로 패킷을 수신 대기하지 않도록 설정합니다.

### <a name="multicast-loopback"></a>멀티캐스트 루프백    
애플리케이션은 동일한 노드의 소스 중 하나에서 시작된 멀티캐스트 트래픽을 수신하려고 할 수 있습니다. 이렇게 하려면 ***nx_igmp_loopback_enable*** 서비스를 사용하여 IP 멀티캐스트 구성 요소가 루프백을 사용하도록 설정해야 합니다.

### <a name="igmp-report-message"></a>IGMP 보고서 메시지      
애플리케이션이 멀티캐스트 그룹에 가입할 때 IGMP 보고서 메시지는 네트워크를 통해 전송되어 특정 멀티캐스트 그룹에 가입하려는 호스트의 의도를 나타냅니다. IGMP 보고서 메시지의 형식은 그림 8에서 확인할 수 있습니다. 멀티캐스트 그룹 주소는 IGMP 보고서 메시지의 그룹 메시지와 대상 IP 주소에 모두 사용됩니다.

위의 그림 8에서 IGMP 헤더에는 버전/유형 필드, 최대 응답이 포함되어 있습니다.

![IGMP 보고서 메시지의 다이어그램입니다.](./media/user-guide/image17.jpg)

**그림 8. IGMP 보고서 메시지**

시간, 체크섬 필드, 멀티캐스트 그룹 주소 필드가 있습니다. IGMPv1 메시지의 경우 최대 응답 시간 필드는 IGMPv1 프로토콜의 일부가 아니므로 항상 0으로 설정됩니다. 최대 응답 시간 필드는 호스트가 쿼리 형식 IGMP 메시지를 수신할 때 설정되고 호스트가 IGMPv2 프로토콜로 정의된 다른 호스트의 보고서 형식 메시지를 수신할 때 삭제됩니다.

다음은 IGMP 헤더 형식에 대한 설명입니다.

|헤더 필드|목적|
|---|---|
|**버전** |이 필드는 IGMP 버전을 지정합니다(31-28비트).|
|**형식** |이 필드는 IGMP 메시지 유형을 지정합니다(27-24비트).|
|**최대 응답 시간** |IGMP 버전 1에서 사용되지 않습니다. IGMP 버전 2에서 이 필드는 최대 응답 시간으로 사용됩니다.|
|**Checksum** |이 필드에는 IGMP 버전으로 시작하는 IGMP 메시지의 1의 보수 합계에 대한 16비트 체크섬이 포함됩니다(0-15비트).|
|**그룹 주소** |32비트 클래스 D 그룹 IP 주소|

또한 IGMP 보고서 메시지는 멀티캐스트 라우터에 의해 전송된 IGMP 쿼리 메시지에 응답하여 전송됩니다. 멀티캐스트 라우터는 그룹 멤버 자격이 여전히 필요한 호스트를 확인하기 위해 주기적으로 쿼리 메시지를 전송합니다. 쿼리 메시지는 그림 8에 표시된 IGMP 보고서 메시지와 동일한 형식을 갖습니다. 유일한 차이점은 IGMP 형식이 1과 같고 그룹 주소 필드는 0으로 설정된다는 것입니다. IGMP 쿼리 메시지는 멀티캐스트 라우터에 의해 ‘모든 호스트’ IP 주소로 전송됩니다. 그룹 멤버 자격을 유지 관리하려는 호스트가 다른 IGMP 보고서 메시지를 전송하여 응답합니다.

> [!NOTE]
> TCP/IP 구현의 모든 메시지는 **big endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.

### <a name="igmp-statistics-and-errors"></a>IGMP 통계 및 오류    
<th><p>사용하도록 설정된 경우 NetX Duo IGMP 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다. 각 IP의 IGMP 처리에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다. 

- 전송된 총 IGMP 보고서 
- 수신된 총 IGMP 쿼리 
- 총 IGMP 체크섬 오류 
- 가입된 총 IGMP 현재 그룹 

이러한 모든 통계 및 오류 보고서는 애플리케이션이 ***nx_igmp_info_get*** 서비스를 사용하여 이용할 수 있습니다. 

### <a name="multicast-without-igmp"></a>IGMP를 사용하지 않은 멀티캐스트  
IPv4 멀티캐스트 트래픽이 예상되는 애플리케이션은 ***nx_ipv4_multicast_interface_join*** 서비스를 사용하여 IGMP 메시지를 호출하지 않고 멀티캐스트 그룹 주소에 가입할 수 있습니다. 이 서비스는 지정된 IPv4 멀티캐스트 주소의 패킷을 허용하도록 IPv4 계층 및 기본 인터페이스 드라이버에 지시합니다. 그러나 이 그룹에 대해 전송하거나 처리 중인 IGMP 그룹 관리 메시지는 없습니다.

애플리케이션은 ***nx_ipv4_multicast_interface_leave*** 서비스를 사용할 수 있는 그룹으로부터 더 이상 트래픽을 수신하지 않으려 합니다.

## <a name="ipv6-in-netx-duo"></a>NetX Duo의 IPv6

### <a name="ipv6-addresses"></a>IPv6 주소   
IPv6 주소는 128비트입니다. IPv6 주소의 아키텍처는 RFC 4291에 설명되어 있습니다. 주소는 가장 중요한 비트를 포함하는 접두사와 낮은 비트를 포함하는 호스트 주소로 구분됩니다. 접두사는 주소 형식을 나타내며 IPv4 네트워크의 네트워크 주소와 거의 동일합니다.

IPv6에는 유니캐스트, 애니캐스트(NetX Duo에서 지원되지 않음), 멀티캐스트의 세 가지 형식의 주소 사양이 있습니다. 유니캐스트 주소는 인터넷에서 특정 호스트를 식별하는 IP 주소입니다. 유니캐스트 주소는 소스 또는 대상 IP 주소일 수 있습니다. 멀티캐스트 주소는 인터넷에 있는 동적 호스트 그룹을 지정합니다. 멀티캐스트 그룹의 멤버는 언제든지 가입하고 탈퇴할 수 있습니다.

IPv6에는 IPv4 브로드캐스트 메커니즘과 동등한 기능이 없습니다. 모든 호스트에 패킷을 보내는 기능은 링크-로컬 모든 호스트 멀티캐스트 그룹에 패킷을 전송함으로써 수행할 수 있습니다.

IPv6는 멀티캐스트 주소를 활용하여 인접 노드 검색, 라우터 검색 및 상태 비저장 주소 자동 구성 프로시저를 수행합니다.

IPv6 유니캐스트 주소에는 두 가지 형식이 있습니다. 일반적으로 잘 알려진 링크 로컬 접두사와 인터페이스 MAC 주소를 결합하여 구성된 링크 로컬 주소 형식과 접두사 부분과 호스트 ID 부분을 포함하는 글로벌 IP 주소 형식입니다. 글로벌 주소는 수동으로 구성하거나 상태 비저장 주소 자동 구성 또는 DHCPv6를 통해 구성할 수 있습니다. NetX Duo는 링크 로컬 주소와 글로벌 주소를 모두 지원합니다.

IPv4 및 IPv6 형식을 모두 수용하기 위해 NetX Duo는 IPv4 및 IPv6 주소를 유지하기 위한 새로운 데이터 형식 NXD_ADDRESS를 제공합니다. 이 구조에 대한 설명은 아래에 나와 있습니다. 주소 필드는 IPv4 및 IPv6 주소 공용입니다.

```c
typedef struct NXD_ADDRESS_STRUCT
{
    ULONG nxd_ip_version;
    union
    {
        ULONG v4;
        ULONG v6[4];
    } nxd_ip_address;
} NXD_ADDRESS;
```

NXD_ADDRESS 구조에서 첫 번째 요소인 *nxd_ip_version* 은 IPv4 또는 IPv6 버전을 나타냅니다. 지원되는 값은 NX_IP_VERSION_V4 또는 NX_IP_VERSION_V6입니다. *nxd_ip_version* 은 *nxd_ip_address* union에서 IP 주소로 사용할 필드를 나타냅니다. NetX Duo API 서비스는 일반적으로 ULONG(32비트) IP 주소 대신 입력 인수로 NXD_ADDRESS 구조에 대한 포인터를 사용합니다.

### <a name="link-local-addresses"></a>링크 로컬 주소     
링크-로컬 주소는 로컬 네트워크에서만 유효합니다. 디바이스는 유효한 링크 로컬 주소를 할당한 후 동일한 네트워크의 다른 디바이스로 패킷을 주고받을 수 있습니다. 애플리케이션에서는 접두사 길이 매개 변수가 10으로 설정된 NetX Duo 서비스 ***nxd_ipv6_address_set*** 을 호출하여 링크-로컬 주소를 할당합니다. 애플리케이션은 서비스에 링크-로컬 주소를 제공하거나, 단순히 NX_NULL을 링크-로컬 주소로 사용하고 NetX Duo가 디바이스의 MAC 주소를 기반으로 링크-로컬 주소를 생성할 수 있습니다.

다음 예에서는 NetX Duo가 MAC 주소를 사용하여 기본 디바이스(인덱스 0)에서 접두사 길이가 10인 링크-로컬 주소를 구성하도록 지시합니다.

```c
nxd_ipv6_address_set(ip_ptr, 0, NX_NULL, 10, NX_NULL);
```
위의 예에서 인터페이스의 MAC 주소가 54:32:10:1A:BC:67인 경우 해당 링크- 로컬 주소는 다음과 같습니다.

```c
FE80::5632:10FF:FE1A:BC67
```
IPv6 주소(**5632:10FF:FE1A:BC67**)의 호스트 ID 부분은 다음과 같은 수정 사항을 포함하여 6바이트 MAC 주소로 구성됩니다.

- MAC 주소의 바이트 3과 바이트 4 사이에 **0xFFFE** 삽입됨
- MAC 주소(U/L 비트)의 첫 번째 바이트의 두 번째로 낮은 비트가 1로 설정됨

인터페이스 MAC 주소에서 IPv6 주소의 호스트 부분을 구성하는 방법에 대한 자세한 내용은 RFC 2464(이더넷 네트워크를 통한 IPv6 패킷 전송)를 참조하세요.

IPv6에서 하나 이상의 호스트로 멀티캐스트 메시지를 전송하기 위한 몇 가지 특수한 멀티캐스트 주소가 있습니다.

| 그룹  | 주소   | Description  |
|---|---|---|
|모든 노드 그룹 |**FF02::1** |로컬 네트워크의 모든 호스트|
|모든 라우터 그룹 |**FF02::2** |로컬 네트워크의 모든 라우터|
|요청된 노드 |**FF02::1:FF00:0/104** |아래 설명을 참조하세요.|

요청된 노드 멀티캐스트 주소는 모든 IPv6 호스트가 아닌 로컬 링크의 특정 호스트를 대상으로 합니다. 104비트인 접두사 **FF02::1:FF00:0/104** 와 대상 IPv6 주소의 마지막 24비트로 구성됩니다. 예를 들어, IPv6 주소 **205B:209D:D028::F058:D1C8:1024** 에는 주소 **FF02::1:FFC8:1024** 의 요청된 노드 멀티캐스트 주소가 있습니다.

> [!IMPORTANT]
> 이중 콜론 표기법은 중간 비트가 모두 0임을 나타냅니다. 완전히 확장된 **FF02::1:FF00:0/104** 는 **FF02:0000:0000:0000:0000:0001:FF00:0000** 과 같이 보입니다. 

### <a name="global-addresses"></a>글로벌 주소    
IPv6 글로벌 주소의 예는 **2001:0123:4567:89AB:CDEF::1** 입니다. NetX Duo는 IPv6 주소를 NXD_ADDRESS 구조에 저장합니다. 아래 예에서 NXD_ADDRESS 변수 **global_ipv6_address** 에 유니캐스트 IPv6 주소가 포함되어 있습니다. 다음 예에서는 NetX Duo 디바이스가 기본 디바이스의 특정 IPv6 글로벌 주소를 만드는 방법을 보여 줍니다.

```c
NXD_ADDRESS global_ipv6_address;
UINT        primary_interface_index = 0;

global_ipv6_address.nxd_ip_version = NX_IP_VERSION_V6;
global_ipv6_address.nxd_ip_address.v6[0] = 0x20010123;
global_ipv6_address.nxd_ip_address.v6[1] = 0x456789AB;
global_ipv6_address.nxd_ip_address.v6[2] = 0xCDEF0000;
global_ipv6_address.nxd_ip_address.v6[3] = 0x00000001;

status = nxd_ipv6_address_set(
            &ip_0,
            primary_interface_index,
            &global_ipv6_address,
            64,
            NX_NULL);
```
이 IPv6 주소의 접두사는 **2001:0123:4567:89AB** 이며 길이는 64비트로서 이더넷의 글로벌 유니캐스트 IPv6 주소에 대한 일반적인 접두사 길이입니다.

또한 NXD_ADDRESS 구조에는 IPv4 주소도 포함됩니다. global_ipv4_address에 저장된 **192.1.168.10**(**0xC001A80A**)의 IP 주소는 다음과 같은 메모리 레이아웃을 갖습니다.

|필드 |값 |
|---|---|
|global_ipv4_address.nxd_ip_version |NX_IP_VERSION_V4|
|global_ipv4_address.nxd_ip_address.v4 |0xC001A80A|

애플리케이션이 NetX Duo 서비스에 주소를 전달할 때 *nxd_ip_version* 필드는 적절한 패킷 처리를 위한 올바른 IP 버전을 지정해야 합니다.

기존 NetX 애플리케이션이 이전 버전과의 호환을 위해 NetX Duo는 모든 NetX 서비스를 지원합니다. 내부적으로 NetX Duo는 IPv4 주소 형식 ULONG을 NXD_ADDRESS 데이터 형식으로 변환한 후 실제 NetX Duo 서비스로 전달합니다.

다음 예에서는 NetX와 NetX Duo의 서비스 간 유사성과 차이점을 보여 줍니다.

```c
/* Make a connection to the destination IPv4 address
   192.1.168.12 through an already created TCP socket bound
   to the well known HTTP port number 80. */

global_ipv4_address.nxd_ip_version = NX_IP_VERSION_V4;
global_ipv4_address.nxd_ip_address.v4 = 0xC001A80C;

nxd_tcp_client_socket_connect(&tcp_socket,
                              &global_ipv4_address,
                              port_number,
                              NX_WAIT_FOREVER);
```

다음은 동일한 NetX API입니다.

```c
ULONG         server_ip = 0xC001A80C;
NX_TCP_SOCKET tcp_socket;
UINT          port_number = 80;

nx_tcp_client_socket_connect(&tcp_socket,
                             server_ip,
                             port_number,
                             NX_WAIT_FOREVER); 
```

> [!IMPORTANT]
> 애플리케이션 개발자는 이러한 API의 nxd 버전을 사용하도록 권장됩니다.

### <a name="ipv6-default-routers"></a>IPv6 기본 라우터    
IPv6는 기본 라우터를 사용하여 오프 링크 대상에 패킷을 전달합니다. NetX Duo 서비스 ***nxd_ipv6_default_router_add*** 를 사용하면 애플리케이션에서 IPv6 라우터를 기본 라우터 테이블에 추가할 수 있습니다. NetX Duo에서 제공하는 기본적인 라우터 서비스는 4장 “서비스 설명”을 참조하세요.  

IPv6 패킷을 전달할 때 NetX Duo는 먼저 패킷 대상이 온-링크인지 확인합니다. 그러지 않은 경우 NetX Duo는 기본 라우팅 테이블에서 오프-링크 패킷을 전달할 유효한 라우터를 확인합니다.  

IPv6 기본 라우터 테이블에서 라우터를 제거하려면 애플리케이션은 ***nxd_ipv6_default_router_delete** _ 서비스를 사용해야 합니다. IPv6 기본 라우터 테이블의 항목을 가져오려면 _*_nxd_ipv6_default_router_entry_get_** 서비스를 사용합니다.

### <a name="ipv6-header"></a>IPv6 헤더    
IPv6 헤더가 IPv4 헤더에서 수정되었습니다. 패킷을 할당할 때 호출자는 애플리케이션 프로토콜(예: UDP, TCP), 버퍼 크기(바이트), 홉 제한을 지정합니다.   

그림 9는 IPv6 헤더의 형식을 보여주며 표에는 헤더 구성 요소가 나열되어 있습니다.

![IPv6 헤더 형식 다이어그램입니다.](./media/user-guide/image18.png)

**그림 9. IPv6 헤더 형식**

|IP 헤더 | 목적 |
|---|---|
|버전 |IP 버전의 4비트 필드입니다. IPv6 네트워크의 경우 이 필드의 값은 6이어야 하며 IPv4 네트워크의 경우 4여야 합니다.|
|트래픽 클래스 |트래픽 클래스 정보를 저장하는 8비트 필드입니다. 이 필드는 NetX Duo에서 사용되지 않습니다.|
|흐름 레이블 |패킷이 연결된 흐름(있는 경우)을 고유하게 식별하는 20비트 필드입니다. 값이 0이면 패킷이 특정 흐름에 속하지 않음을 나타냅니다. 이 필드는 IPv4의 *TOS* 필드를 대체합니다.|
|페이로드 길이 |IPv6 기본 헤더 뒤에 있는 IPv6 패킷의 바이트 단위의 데이터 양을 나타내는 16비트 필드입니다. 여기에는 모든 캡슐화된 프로토콜 헤더와 데이터가 포함됩니다.|
|다음 헤더 | IPv6 기본 헤더 뒤에 오는 확장 헤더의 형식을 나타내는 8비트 필드입니다. 이 필드는 IPv4의 ‘프로토콜’ 필드를 대체합니다.|
|홉 제한 |패킷이 통과할 수 있는 라우터 수를 제한하는 8비트 필드입니다. 이 필드는 IPv4의 *TTL* 필드를 대체합니다.|
|소스 주소 |보낸 사람의 IPv6 주소를 저장하는 128비트 필드입니다.|
|대상 주소 |대상의 IPv6 주소를 저장하는 128비트 필드입니다.|

### <a name="enabling-ipv6-in-netx-duo"></a>NetX Duo에서 IPv6 사용    
기본적으로 IPv6는 NetX Duo에서 사용하도록 설정됩니다. 구성 가능한 옵션 ***NX_DISABLE_IPV6** _가 _nx_user.h*에서 정의되지 않은 경우 IPv6 서비스는 NetX Duo에서 사용할 수 있도록 설정됩니다. ***NX_DISABLE_IPV6*** 가 정의되면 NetX Duo는 IPv4 서비스만 제공할 뿐 모든 IPv6 관련 모듈과 서비스는 NetX Duo 라이브러리에 기본 제공되지 않습니다.

디바이스 IPv6 주소를 구성하는 애플리케이션에 대해 다음 서비스가 제공됩니다. ***nxd_ipv6_address_set***

시스템은 디바이스의 IPv6 주소를 수동으로 설정할 뿐 아니라 상태 비저장 주소 자동 구성도 사용할 수 있습니다. 이 옵션을 사용하려면 애플리케이션에서 ***nxd_ipv6_enable** _을 호출하여 디바이스에서 IPv6 서비스를 시작해야 합니다. 또한 _*_nxd_icmp_enable_*_ 을 호출하여 ICMPv6 서비스를 시작해야 하며 이를 통해 NetX Duo에서 라우터 요청, 인접 노드 검색, 중복 주소 검색 등의 서비스를 수행할 수 있습니다. _*_nx_icmp_enable_*_ 은 IPv4 서비스에 대해서만 ICMP를 시작합니다. _*_nxd_icmp_enable_*_ 은 IPv4 및 IPv6 모두에 대해 ICMP 서비스를 시작합니다. 시스템에 ICMPv6 서비스가 필요하지 않은 경우 _ *_nx_icmp_enable_**을 사용하여 ICMPv6 모듈이 시스템에 연결되지 않도록 할 수 있습니다.

다음 예는 일반적인 NetX Duo IPv6 초기화 프로시저를 보여 줍니다.

```c
/* Assume ip_0 has been created and IPv4 services (such as ARP,
   ICMP, have been enabled. */
#define SECONDARY_INTERFACE 1

/* Enable IPv6 */
status = nxd_ipv6_enable(&ip_0);

if(status != NX_SUCCESS)
{
    /* nxd_ipv6_enable failed. */
}

/* Enable ICMPv6 */
status = nxd_icmp_enable(&ip_0);
if(status != NX_SUCCESS)
{
    /* nxd_icmp_enable failed. */
}

/* Configure the link local address on the primary interface. */
status = nxd_ipv6_address_set(&ip_0, 0, NX_NULL, 10, NX_NULL);

/* Configure ip_0 primary interface global address. */
ip_address.nxd_ip_version = NX_IP_VERSION_V6
ip_address.nxd_ip_address.v6[0] = 0x20010db8;
ip_address.nxd_ip_address.v6[1] = 0x0000f101;
ip_address.nxd_ip_address.v6[2] = 0;
ip_address.nxd_ip_address.v6[3] = 0x202;

/* Configure global address of the primary interface. */
status = nxd_ipv6_address_set(&ip_0, SECONDARY_INTERFACE,
                              &ip_address, 64, NX_NULL);
```                              

상위 계층 프로토콜(예: TCP 및 UDP)은 IPv6 시작 전이나 후에 사용할 수 있습니다.

> [!IMPORTANT]  
> IPv6 서비스는 IP 스레드를 초기화하고 디바이스가 사용하도록 설정된 후에만 사용할 수 있습니다.

인터페이스를 사용하도록 설정한 후(즉, 인터페이스 디바이스 드라이버가 데이터를 주고받을 준비가 되어 있고 유효한 링크 로컬 주소를 가져온 경우) 디바이스는 다음 방법의 하나로 글로벌 IPv6 주소를 가져올 수 있습니다.

- 상태 비저장 주소 자동 구성  
- 수동 IPv6 주소 구성  
- DHCPv6를 통한 주소 구성(선택 사항인 DHCPv6 패키지 포함)

처음 두 가지 방법은 아래에 설명되어 있습니다. 세 번째 방법(DHCPv6)은 DHCP 패키지에 설명되어 있습니다.

### <a name="stateless-address-autoconfiguration-using-router-solicitation"></a>라우터 요청을 사용한 상태 비저장 주소 자동 구성      
NetX Duo 디바이스는 접두사 정보를 제공하는 라우터를 사용하여 IPv6 네트워크에 연결하면 인터페이스를 자동으로 구성할 수 있습니다. 상태 비저장 주소 자동 구성이 필요한 디바이스는 RS(라우터 요청) 메시지를 전송합니다. 네트워크의 라우터는 요청된 RA(라우터 알림) 메시지로 응답합니다. RA 메시지는 링크와 연결된 네트워크 주소를 식별하는 접두사를 보급합니다. 그런 다음 디바이스는 디바이스가 연결된 네트워크에 대한 고유 식별자를 생성합니다. 주소는 접두사와 고유 식별자를 결합하여 형성됩니다. 이러한 방식으로 RA 메시지를 수신하면 호스트는 IP 주소를 생성합니다. 라우터는 주기적으로 원치 않는 RA 메시지를 전송할 수도 있습니다. 

> [!WARNING]
> NetX Duo를 사용하면 애플리케이션이 런타임에 상태 비저장 주소 자동 구성을 사용하거나 사용하지 않도록 설정할 수 있습니다. 이 기능을 사용하려면 **NX_IPV6_STATELESS_AUTOCONFIG_CONTROL** 이 정의된 상태로 NetX Duo 라이브러리를 컴파일해야 합니다. 이 기능을 사용하도록 설정한 후 애플리케이션이 **nxd_ipv6_stateless_address_autoconfigure_enable** 및 **nxd_ipv6_stateless_address_autocofigure_disable** 을 사용하여 IPv6 상태 비저장 주소 자동 구성을 사용하거나 사용하지 않도록 설정할 수 있습니다.

### <a name="manual-ipv6-address-configuration"></a>수동 IPv6 주소 구성     
특정 IPv6 주소가 필요한 경우 애플리케이션은 ***nxd_ipv6_address_set*** 을 사용하여 IPv6 주소를 수동으로 구성할 수 있습니다. 네트워크 인터페이스에는 여러 IPv6 주소가 있을 수 있습니다. 그러나 상태 비저장 주소 자동 구성을 통하거나 수동 구성을 통해 얻어진 시스템의 총 IPv6 주소 수는 ***NX_MAX_IPV6_ADDRESSES*** 를 초과할 수 없습니다.

다음 예에서는 ip_0의 기본 인터페이스(디바이스 0)에서 글로벌 주소를 수동으로 구성하는 방법을 보여 줍니다.

```c
NXD_ADDRESS global_address;
global_address.nxd_ip_version = NX_IP_VERSION_V6;
global_address.nxd_ip_address.v6[0] = 0x20010000;
global_address.nxd_ip_address.v6[1] = 0x00000000;
global_address.nxd_ip_address.v6[2] = 0x00000000;
global_address.nxd_ip_address.v6[3] = 0x0000ABCD;
```

그런 다음 호스트는 다음 NetX Duo 서비스를 호출하여 이 주소를 글로벌 IP 주소로 할당합니다.

```c
status = nxd_ipv6_address_set(&ip_0, 0,  
                              &global_address, 64
                              NX_NULL);
```

### <a name="duplicate-address-detection-dad"></a>DAD(중복 주소 검색)    
시스템에서 IPv6 주소를 구성하면 주소가 *TENTATIVE* 로 표시됩니다. RFC 4862에 설명된 DAD(중복 주소 검색)를 사용하도록 설정하면 NetX Duo는 이 임시 주소를 대상으로 NS(인접 노드 요청) 메시지를 자동으로 전송합니다. 네트워크에 있는 호스트가 주어진 시간 내에 NS 메시지에 응답하지 않으면 해당 주소는 로컬 링크에서 고유한 것으로 간주되고 그 상태는 VALID 상태로 전환됩니다. 이때 애플리케이션은 이 IP 주소를 사용하여 통신을 시작할 수 있습니다.  

DAD 기능은 ICMPv6 모듈의 일부입니다. 따라서 새로 구성된 주소가 DAD 프로세스를 통과하려면 애플리케이션이 ICMPv6 서비스를 사용하도록 설정해야 합니다. 또는 NetX Duo 라이브러리 빌드 환경(_*_nx_user.h_*_ 로 정의됨)에서 ***NX_DISABLE_IPV6_DAD** _ 옵션을 정의하여 DAD 프로세스를 해제할 수 있습니다. DAD 프로세스 중에 _*_NX_IPV6_DAD_TRANSMITS_*_ 매개 변수는 주소가 고유하다는 응답을 수신하지 않고 NetX Duo에서 보낸 NS 메시지 수를 결정합니다. 기본적으로 RFC 4862에서 권장되며 _ *_NX_IPV6_DAD_TRANSMITS_**는 3으로 설정됩니다. 이 기호를 0으로 설정하면 DAD를 효과적으로 사용하지 않을 수 있습니다.

애플리케이션이 IPv6 주소를 할당할 때 ICMPv6 또는 DAD를 사용하도록 설정하지 않으면 DAD가 수행되지 않고 NetX Duo는 IPv6 주소의 상태를 즉시 VALID로 설정합니다.

NetX Duo는 해당 링크 로컬 및/또는 글로벌 주소가 유효할 때까지 IPv6 네트워크에서 통신할 수 없습니다. 유효한 주소를 가져온 후, NetX Duo는 구성된 IPv6 주소 또는 활성화된 멀티캐스트 주소 중 하나에 대해 들어오는 패킷의 대상 주소를 일치시키려고 시도합니다. 일치하는 항목이 없으면 패킷이 삭제됩니다. 

> [!WARNING]  
> *DAD 프로세스 중에 전송할 DAD NS 패킷 수는 ***NX_IPV6_DAD_TRANSMITS**_로 정의되며 기본값은 3으로 설정되고, 기본적으로 각 DAD NS 메시지가 전송되는 사이에 1초 지연이 발생합니다. 따라서 DAD를 사용하는 시스템에서 IPv6 주소가 할당된 후(중복된 주소가 아닌 경우) IP 주소가 VALID 상태로 통신할 준비가 되기까지 약 3초 지연이 발생합니다._

애플리케이션에서 시스템의 IPv6 주소가 변경될 때 알림을 수신하려고 할 수 있습니다. IPv6 주소 변경 알림 기능을 사용하도록 설정하려면 **NX_ENABLE_IPV6_ADDRESS_CHANGE_NOTIFY** 가 정의된 기호를 사용하여 NetX Duo 라이브러리를 빌드해야 합니다. 해당 기능을 사용하도록 설정한 후에는 애플리케이션이 **_nxd_ipv6_address_change_notify_** 서비스를 사용하여 콜백 함수를 설치할 수 있습니다.

IPv6 주소가 변경되거나 잘못되면 다음 정보를 사용하여 사용자 제공 콜백 함수가 호출됩니다.

| 기능  | Description  |
|---|---|
|ip_ptr |IP 인스턴스에 대한 포인터|
|interface_index |이 IPv6 주소가 연결된 네트워크 인터페이스에 대한 인덱스
|ipv6_addr_index |IPv6 주소 테이블에 대한 인덱스|
|ipv6_address |4개의 ULONG 정수 배열 형식의 IPv6 주소에 대한 포인터입니다. IPv6 주소는 호스트 바이트 순서로 표시됩니다.|

### <a name="ipv6-multicast-support-in-netx-duo"></a>NetX Duo의 IPv6 멀티캐스트 지원      
멀티캐스트 주소는 인터넷에 있는 동적 호스트 그룹을 지정합니다. 멀티캐스트 그룹의 멤버는 언제든지 가입하고 탈퇴할 수 있습니다. NetX Duo는 IP 멀티캐스트 기능이 필요한 중복 주소 검색, 인접 노드 검색, 라우터 검색을 포함한 여러 ICMPv6 프로토콜을 구현합니다. 따라서 NetX Duo는 기본 디바이스 드라이버가 멀티캐스트 작업을 지원할 것으로 예상합니다.

NetX Duo가 멀티캐스트 그룹(예: 모든 노드 멀티캐스트 주소 및 ‘요청된 노드’ 멀티캐스트 주소)에 가입하거나 이 그룹에서 탈퇴해야 할 때, 멀티캐스트 MAC 주소에 가입하거나 이 주소에서 탈퇴하라는 드라이버 명령을 디바이스 드라이버에 대해 실행합니다. 멀티캐스트 주소에 가입하라는 드라이버 명령은 ***NX_LINK_MULTICAST_JOIN** _입니다. 멀티캐스트 주소에서 탈퇴하기 위해 NetX Duo는 _*_NX_LINK_MULTICAST_LEAVE_** 드라이버 명령을 실행합니다. ICMPv6 프로토콜이 제대로 작동하려면 디바이스 드라이버가 이 두 명령을 구현해야 합니다.

애플리케이션은 ***nxd_ipv6_multicast_interface_join*.** 서비스를 사용하여 IPv6 멀티캐스트 그룹에 가입할 수 있습니다. 이 서비스는 IP 스택을 사용하여 멀티캐스트 주소를 등록한 다음, 지정된 디바이스 드라이버에 IPv6 멀티캐스트 주소를 알립니다. 멀티캐스트 그룹에서 탈퇴하기 위해 애플리케이션은 ***nxd_ipv6_multicast_interface_leave*** 서비스를 사용합니다.

### <a name="neighbor-discovery-nd"></a>ND(인접 노드 검색)    
인접 노드 검색은 IPv6 주소(글로벌 주소 또는 링크-로컬 주소)에 물리적 주소를 매핑하기 위한 IPv6 네트워크의 프로토콜입니다. 이 매핑은 ND Cache(인접 노드 검색 캐시)에서 유지 관리됩니다. ND 프로세스는 IPv4의 ARP 프로세스와 동일하며 ND 캐시는 ARP 테이블과 유사합니다. IPv6 노드는 ND(인접 노드 검색) 프로토콜을 사용하여 인접 노드의 MAC 주소를 가져올 수 있습니다. 이는 모든 노드의 요청된 노드 멀티캐스트 주소에 NS(인접 노드 요청) 메시지를 보내고, 해당하는 NA(인접 노드 알림) 메시지를 기다립니다. 이 프로세스를 통해 가져온 MAC 주소는 ND 캐시에 저장됩니다.

각 IP 인스턴스에는 하나의 ND 캐시가 있습니다. ND 캐시는 항목 배열로 유지 관리됩니다. 배열의 크기는 컴파일 시간에 ***NX_IPV6_NEIGHBOR_CACHE_SIZE** _에 있는 _*_nx_user.h_** 옵션을 설정하여 정의됩니다. IP 인스턴스에 연결된 모든 인터페이스는 동일한 ND 캐시를 공유합니다.

NetX Duo가 시작될 때 전체 ND 캐시는 비어 있습니다. 시스템이 실행되면 NetX Duo는 ND 캐시를 자동으로 업데이트하여 ND 프로토콜에 따라 항목을 추가 및 삭제합니다. 그러나 애플리케이션은 다음 NetX Duo 서비스를 사용하여 캐시 항목을 수동으로 추가하고 삭제함으로써 ND 캐시를 업데이트할 수도 있습니다.

- ***nxd_nd_cache_entry_delete***  
- ***nxd_nd_cache_entry_set***   
- ***nxd_nd_cache_invalidate***

IPv6 패킷을 주고받을 때 NetX Duo는 ND 캐시 테이블을 자동으로 업데이트합니다.

## <a name="internet-control-message-protocol-in-ipv6-icmpv6"></a>ICMPv6(IPv6의 Internet Control Message Protocol)  

IPv6에서 ICMPv6의 역할이 크게 확장되어 IPv6 주소 매핑과 라우터 검색을 지원합니다. 또한 NetX Duo ICMPv6는 에코 요청 및 응답, ICMPv6 오류 보고서, ICMPv6 리디렉션 메시지를 지원합니다.

### <a name="icmpv6-enable"></a>ICMPv6 사용    
NetX Duo에서 ICMPv6 메시지를 처리하려면 먼저 애플리케이션이 앞에서 설명한 대로 ***nxd_icmp_enable*** 서비스를 호출하여 ICMPv6를 처리하도록 설정해야 합니다. 

### <a name="icmpv6-messages"></a>ICMPv6 메시지     
ICMPv6 헤더 구조는 ICMPv4 헤더 구조와 유사합니다. 아래와 같이 기본 ICMPv6 헤더에는 형식, 코드, 체크섬의 세 필드와 ICMPv6 옵션 데이터의 가변 길이가 포함됩니다. 

![기본 ICMPv6 헤더의 다이어그램입니다.](./media/user-guide/image19.png)

**그림 10. 기본 ICMPv6 헤더**

|필드 |크기(바이트) |Description |
|-----|-----|-----|
|     | 1   |ICMPv6 메시지 유형을 식별합니다. |
|     |     |1 대상에 연결할 수 없음 |
|     |     |2 패킷이 너무 큼 |
|     |     |3 시간 초과 |
|     |     |4 매개 변수 문제 |
|     |     |128 에코 요청 |
|     |     |129 에코 응답 |
|     |     |133 라우터 요청 |
|     |     |134 라우터 알림 |
|     |     |135 인접 노드 요청 |
|     |     |136 인접 노드 알림 |
|     |     |137 리디렉션 메시지 |
|코드 | 1   |ICMPv6 메시지 유형을 추가로 검증합니다. 일반적으로 오류 메시지와 함께 사용됩니다. 사용되지 않으면 0으로 설정됩니다. 에코 요청/응답 및 NS 메시지는 이를 사용하지 않습니다.|
|체크섬 | 2 |ICMP 헤더에 대한 16비트 체크섬 필드입니다. 이는 ICMPv6 헤더를 포함한 전체 ICMPv6 메시지의 16비트 보수입니다. 또한 IPv6 소스 주소, 대상 주소, 패킷 페이로드 길이의 의사 헤더도 포함합니다. |

다음은 인접 노드 요청 헤더의 예제입니다.

![인접 노드 요청 헤더 예제의 다이어그램입니다.](./media/user-guide/image20.jpg)

**그림 11. 인접 노드 요청 메시지의 ICMPv6 헤더**

|필드 |크기(바이트) |Description |
|-----|-----|-----|
|형식 | 1   |인접 노드 요청 메시지의 ICMPv6 메시지 유형을 식별합니다. 값은 135입니다. |
|코드 | 1   |사용되지 않습니다. 0으로 설정합니다. |
|체크섬 | 2  |ICMPv6 헤더에 대한 16비트 체크섬 필드입니다. |
|예약됨 | 4  |예약된 4바이트가 0으로 설정되었습니다. |
|대상 주소 | 16  |요청 대상의 IPv6 주소입니다. IPv6 주소 확인을 위해 링크 계층 주소를 확인해야 하는 디바이스의 실제 유니캐스트 IP 주소입니다. |
|옵션 | 변수 |인접 노드 검색 프로토콜에서 지정한 선택적 정보입니다. |

### <a name="icmpv6-ping-request"></a>ICMPv6 Ping 요청
NetX Duo 애플리케이션에서 ***nxd_icmp_ping*** 을 사용하여 매개 변수에 지정된 대상 IP 주소를 기반으로 IPv6 또는 IPv4 ping 요청을 실행합니다.  

### <a name="icmpv6-ping-response"></a>ICMPv6 Ping 응답
ICMPv6 ping 응답은 ICMPv6 구성 요소에서 외부 ICMPv6 ping 요청에 응답하여 내부적으로 생성하는 또 다른 유형의 ICMPv6 메시지입니다. ICMPv6 ping 응답에는 승인 외에도 ICMPv6 ping 요청에 제공된 사용자 데이터 복사본도 포함됩니다.  

### <a name="thread-suspension"></a>스레드 일시 중단
다른 네트워크 멤버를 ping하는 동안 애플리케이션 스레드가 일시 중단될 수 있습니다. ping 응답이 수신되면 ping 응답 메시지가 일시 중단된 첫 번째 스레드에 전달되고 해당 스레드가 다시 시작됩니다. 모든 NetX Duo 서비스와 마찬가지로 ping 요청이 일시 중단되면 선택적 시간 제한이 발생합니다.  

### <a name="other-icmpv6-messages"></a>기타 ICMPv6 메시지
ICMPv6 메시지는 다음과 같은 기능에 필요합니다.  

- 네트워크 환경 검색  
- 상태 비저장 주소 자동 구성 
- 라우터 검색 
- 인접 노드 연결 불가 감지  

### <a name="neighbor-unreachability-router-and-prefix-discovery"></a>인접 노드 연결 불가, 라우터 및 접두사 검색    
인접 노드 연결 불가 감지, 라우터 검색, 접두사 검색은 인접 노드 검색 프로토콜을 기반으로 하며 아래에 설명되어 있습니다. 

***인접 노드 연결 불가 감지:*** IPv6 디바이스는 패킷을 전송하려 할 때 대상 링크 계층 주소를 찾기 위해 ND(인접 노드 검색) 캐시를 검색합니다. ‘다음 홉’이라고도 하는 직접 대상은 동일한 링크의 실제 대상이 될 수도 있고 대상이 오프 링크일 경우에는 라우터가 될 수도 있습니다. ND 캐시 항목은 인접 노드의 연결 가능성에 대한 상태를 포함합니다.

REACHABLE 상태는 인접 노드가 연결할 수 있는 것으로 간주됨을 나타냅니다. 인접 노드로 전송된 패킷이 수신되었다는 확인을 최근에 받은 경우 인접 노드에 연결할 수 있습니다. NetX Duo의 확인은 NetX Duo 디바이스에 의해 전송되는 NS 메시지에 대한 응답으로 인접 노드로부터 NA 메시지를 수신하는 형태를 취합니다. 또한 NetX Duo는 애플리케이션에서 NetX Duo 서비스 ***nxd_nd_cache_entry_set*** 을 호출하여 캐시 레코드를 수동으로 입력하는 경우 인접 노드의 상태를 REACHABLE로 변경합니다.

***라우터 검색:*** IPv6 디바이스는 라우터를 사용하여 오프 링크 대상으로 지정된 모든 패킷을 전달합니다. 또한 라우터에서 보내는 RA(라우터 알림) 메시지와 같은 정보를 사용하여 글로벌 IPv6 주소를 구성할 수도 있습니다.

네트워크의 디바이스는 RS(라우터 요청) 메시지를 모든 라우터 멀티캐스트 주소(FF01::2)로 전송하여 라우터 검색 프로세스를 시작할 수 있습니다. 또는 라우터에서 주기적인 RA를 위해 모든 노드 멀티캐스트 주소(FF::1)에서 대기할 수 있습니다.

RA 메시지에는 해당 네트워크의 IPv6 주소를 구성하기 위한 접두사 정보가 포함됩니다. NetX Duo에서 라우터 요청은 기본적으로 사용하도록 설정되어 있으며, _*_nx_user.h_**에서 구성 옵션 ***NX_DISABLE_ICMPV6_ROUTER_SOLICITATION** _을 설정하여 사용하지 않도록 설정할 수 있습니다. 라우터 요청 매개 변수 설정에 대한 자세한 내용은 “NetX Duo의 설치 및 사용” 장의 구성 옵션을 참조하세요. 

***접두사 검색***: IPv6 디바이스는 접두사 검색을 사용하여 라우터를 통하지 않고 직접 액세스할 수 있는 대상 호스트를 알아봅니다. 이 정보는 라우터의 RA 메시지에서 IPv6 디바이스에 제공됩니다. IPv6 디바이스는 접두사 테이블에 접두사 정보를 저장합니다. 접두사 검색은 IPv6 디바이스 접두사 테이블의 접두사를 대상 주소에 일치시킵니다. 접두사의 모든 비트가 대상 주소의 가장 중요한 비트와 일치하는 경우 접두사는 대상 주소와 일치합니다. 두 개 이상의 접두사가 주소에 사용되는 경우 가장 긴 접두사가 선택됩니다.

### <a name="icmpv6-error-messages"></a>ICMPv6 오류 메시지    
다음 ICMPv6 오류 메시지는 NetX Duo에서 지원됩니다.  

- 대상에 연결할 수 없음  
- 패킷이 너무 큼  
- 시간 초과  
- 매개 변수 문제  

## <a name="user-datagram-protocol-udp"></a>UDP(User Datagram Protocol)

UDP(User Datagram Protocol)는 네트워크 멤버(RFC 768) 간에 가장 간단한 형식으로 데이터를 전송합니다. UDP 데이터 패킷은 한 네트워크 멤버에서 다른 네트워크 멤버로 최상의 방법으로 전송됩니다. 즉, 패킷 수신자의 확인을 위한 기본 제공 메커니즘은 제공되지 않습니다. 또한 UDP 패킷을 전송할 때 미리 연결할 필요가 없습니다. 따라서 UDP 패킷 전송은 매우 효율적입니다.

NetX 애플리케이션을 NetX Duo로 마이그레이션하는 개발자의 경우 NetX와 NetX Duo 간의 UDP 기능에 몇 가지 기본적인 변경 사항만 있습니다. 이는 IPv6가 주로 기본 IP 계층과 관련이 있기 때문입니다. 모든 NetX Duo UDP 서비스는 IPv4 또는 IPv6 연결에 사용할 수 있습니다.

### <a name="udp-header"></a>UDP 헤더       
UDP는 전송 중인 애플리케이션의 데이터 앞에 간단한 패킷 헤더를 배치하고, 수신된 UDP 패킷을 애플리케이션에 전송하기 전에 수신한 패킷에서 유사한 UDP 헤더를 제거합니다. UDP는 패킷을 주고받기 위해 IP 프로토콜을 활용하는데, 이는 패킷이 네트워크에 있을 때 UDP 헤더 앞에 IP 헤더가 있음을 의미합니다. 그림 12는 UDP 헤더의 형식을 보여 줍니다.

![UDP 헤더 형식 다이어그램입니다.](./media/user-guide/image21.png)

### <a name="figure-12-udp-header"></a>그림 12. UDP 헤더

> [!NOTE]
> UDP/IP 구현의 모든 헤더는 **big endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.

다음은 UDP 헤더 형식에 대한 설명입니다.

|헤더 필드 |목적 |
|---|---|
|**16비트 소스 포트 번호** |이 필드에는 UDP 패킷을 전송할 포트가 포함되어 있습니다. 유효한 UDP 포트의 범위는 1에서 0xFFFF까지입니다. |
|**16비트 대상 포트 번호** |이 필드에는 패킷을 전송할 UDP 포트가 포함되어 있습니다. 유효한 UDP 포트의 범위는 1에서 0xFFFF까지입니다. |
|**16비트 UDP 길이** |이 필드에는 UDP 헤더의 크기를 포함하여 UDP 패킷의 바이트 수가 포함됩니다. |
|**16비트 UDP 체크섬** |이 필드에는 UDP 헤더, 패킷 데이터 영역, 의사 IP 헤더를 포함하여 패킷에 대한 16비트 체크섬이 포함됩니다. |

### <a name="udp-enable"></a>UDP 사용   
UDP 패킷을 전송하려면 먼저 ***nx_udp_enable*** 서비스를 호출하여 애플리케이션에서 UDP를 사용하도록 설정해야 합니다. 사용하도록 설정된 후 애플리케이션은 UDP 패킷을 자유롭게 주고받을 수 있습니다.  

### <a name="udp-socket-create"></a>UDP 소켓 만들기    
UDP 소켓은 초기화 중에 또는 애플리케이션 스레드에 의한 런타임 중에 만들어집니다. 초기 서비스 유형, TTL(Time to Live), 수신 큐 깊이는 ***nx_udp_socket_create*** 서비스에 의해 정의됩니다. 애플리케이션의 UDP 소켓 수에는 제한이 없습니다.

### <a name="udp-checksum"></a>UDP 체크섬   
IPv6 프로토콜에는 패킷 데이터에 UDP 헤더 체크섬 계산이 필요하지만 IPv4 프로토콜에서는 선택 사항입니다.  

UDP는 IP 의사 헤더(소스 IP 주소, 대상 IP 주소, 프로토콜/길이 IP 단어로 구성), UDP 헤더, UDP 패킷 데이터를 포함하는 1의 보수 16비트 체크섬을 지정합니다. IPv4와 IPv6 UDP 패킷 헤더 체크섬의 유일한 차이점은 소스 및 대상 IP 주소가 IPv4에서 32비트인 반면 IPv6에서는 128비트라는 점입니다. 계산된 UDP 체크섬이 0이면 모두 1로 저장됩니다(0xFFFF). 전송 소켓에 UDP 체크섬 논리가 사용할 수 없는 경우, 0이 UDP 체크섬 필드에 배치되어 체크섬이 계산되지 않았음을 나타냅니다.

UDP 체크섬이 받는 사람에 의해 계산된 체크섬과 일치하지 않으면 UDP 패킷은 폐기됩니다.

IPv4 네트워크에서 UDP 체크섬은 선택 사항입니다. NetX Duo를 사용하면 애플리케이션이 소켓 단위로 UDP 체크섬 계산을 사용하거나 사용하지 않도록 설정할 수 있습니다. 기본적으로 UDP 소켓 체크섬 논리를 사용할 수 있습니다. 애플리케이션은 ***nx_udp_socket_checksum_disable** _ 서비스를 호출하여 특정 UDP 소켓에 대한 체크섬 논리를 사용하지 않도록 설정할 수 있습니다. 그러나 IPv6 네트워크에서는 UDP 체크섬이 필수입니다. 따라서 IPv6 네트워크를 통해 패킷을 전송할 때 _ *_nx_udp_socket_checksum_disable_** 서비스가 UDP 체크섬 논리를 사용하지 않도록 설정하지 않습니다.

특정 이더넷 컨트롤러는 즉시 UDP 체크섬을 생성할 수 있습니다. 시스템이 하드웨어 체크섬 계산 기능을 사용할 수 있는 경우, NetX Duo 라이브러리를 체크섬 논리 없이 빌드할 수 있습니다. UDP 소프트웨어 체크섬을 사용하지 않도록 설정하려면 다음 기호를 정의하여 NetX Duo 라이브러리를 빌드해야 합니다. 기호 ***NX_DISABLE_UDP_TX_CHECKSUM** _ 및 _*_NX_DISABLE_UDP_RX_CHECKSUM_*_ 은 2장에 설명되어 있습니다. 구성 옵션은 NetX Duo에서 UDP 체크섬 논리를 완전히 제거할 수 있지만 _ *_nx_udp_socket_checksum_disable_** 서비스를 호출하면 애플리케이션에서 소켓 단위로 IPv4 UDP 체크섬 처리를 사용하지 않도록 설정할 수 있습니다.

### <a name="udp-ports-and-binding"></a>UDP 포트 및 바인딩      
UDP 포트는 UDP 프로토콜의 논리적 끝점입니다. NetX Duo의 UDP 구성 요소에는 65,535개의 유효한 포트가 있으며, 범위는 1~0xFFFF입니다. UDP 데이터를 주고받으려면 먼저 애플리케이션에서 UDP 소켓을 만든 다음 원하는 포트에 바인딩해야 합니다. UDP 소켓을 포트에 바인딩한 후 애플리케이션은 해당 소켓에서 데이터를 주고받을 수 있습니다.

### <a name="udp-fast-pathtrade"></a>UDP 빠른 경로&trade;   
UDP 빠른 경로&trade;는 NetX Duo UDP 구현을 통한 낮은 패킷 오버헤드 경로에 대한 이름입니다. UDP 패킷을 전송하려면 ***nx_udp_socket_send** _, _*_nx_ip_packet_send_*_, 네트워크 드라이버에 대한 최종 호출과 같은 몇 가지 함수 호출만 필요합니다. _*_nx_udp_socket_send_*_ 는 기존 NetX 애플리케이션에 대해 NetX Duo에서 사용할 수 있으며 IPv4 패킷에만 적용됩니다. 그러나 기본 방법은 아래에서 설명하는 _ *_nxd_udp_socket_send_** 서비스를 사용하는 것입니다. UDP 패킷 수신 시, UDP 패킷은 적절한 UDP 소켓 수신 큐에 배치되거나 네트워크 드라이버 수신 인터럽트 처리에서 단일 함수 호출로 일시 중단된 애플리케이션 스레드에 전달됩니다. UDP 패킷을 주고받기 위해 최적화된 이 논리는 UDP 빠른 경로 기술의 핵심입니다.  

### <a name="udp-packet-send"></a>UDP 패킷 전송    
IPv6 또는 IPv4 네트워크를 통해 UDP 데이터를 전송하는 작업은 ***nxd_udp_socket_send** _ 함수를 호출하여 쉽게 수행할 수 있습니다. 호출자는 NXD_ADDRESS 포인터 매개 변수의 _nx_ip_version* 필드에 IP 버전을 설정해야 합니다. NetX Duo는 대상 IPv4/IPv6 주소를 기반으로 전송된 UDP 패킷에 가장 적합한 소스 주소를 결정합니다. 이 서비스는 패킷 데이터 앞에 UDP 헤더를 배치하고 내부 IP 전송 루틴을 사용하여 이를 네트워크로 전송합니다. 모든 UDP 패킷 전송이 즉시 처리되므로 UDP 패킷을 전송할 때 스레드가 일시 중단되지 않습니다. 

멀티캐스트 또는 브로드캐스트 대상에 대해 애플리케이션은 NetX Duo 디바이스가 선택할 여러 IP 주소를 가지고 있는 경우 사용할 소스 IP 주소를 지정해야 합니다. 이 작업은 ***nxd_udp_socket_source_send*** 서비스를 이용하여 수행할 수 있습니다.

> [!IMPORTANT]    
> **nx_udp_socket_send** 가 멀티캐스트 또는 브로드캐스트 패킷 전송에 사용되는 경우 첫 번째 사용 가능한 인터페이스의 IP 주소가 소스 주소로 사용됩니다.

> [!NOTE] 
> 이 소켓에 대해 UDP 체크섬 논리를 사용하는 경우 UDP 또는 IP 데이터 구조에 대한 액세스를 차단하지 않고 호출 스레드의 컨텍스트에서 체크섬 작업이 수행됩니다. 

> [!WARNING]    
> NX_PACKET 구조에 있는 UDP 페이로드 데이터는 긴 단어 경계에 있어야 합니다. 애플리케이션에서 NetX Duo가 UDP, IP, 실제 미디어 헤더를 배치할 수 있도록 앞에 추가 포인터와 데이터 시작 포인터 사이에 충분한 공간을 남겨 두어야 합니다.

### <a name="udp-packet-receive"></a>UDP 패킷 수신    
애플리케이션 스레드는 ***nx_udp_socket_receive*** 를 호출하여 특정 소켓에서 UDP 패킷을 수신할 수 있습니다. 소켓 수신 함수는 소켓의 수신 큐에서 가장 오래된 패킷을 전달합니다. 수신 큐에 패킷이 없는 경우 패킷이 도착할 때까지 호출 스레드가 선택적 시간 제한으로 일시 중단될 수 있습니다.

UDP 수신 패킷 처리(일반적으로 네트워크 드라이버의 수신 인터럽트 처리기에서 호출됨)는 패킷을 UDP 소켓의 수신 큐에 배치하거나 패킷을 대기 중인 첫 번째 일시 중단된 스레드로 전달하는 역할을 합니다. 패킷이 큐에 있는 경우 수신 처리는 소켓과 관련된 최대 수신 큐 깊이도 확인합니다. 새로 큐에 배치된 패킷이 큐 깊이를 초과하면 큐에서 가장 오래된 패킷이 삭제됩니다.

### <a name="udp-receive-notify"></a>UDP 수신 알림   
애플리케이션 스레드가 둘 이상의 소켓에서 수신된 데이터를 처리해야 하는 경우 ***nx_udp_socket_receive_notify*** 함수를 사용해야 합니다. 이 함수는 소켓에 대한 수신 패킷 콜백 함수를 등록합니다. 패킷이 소켓에 수신될 때마다 콜백 함수가 실행됩니다.

콜백 함수의 콘텐츠는 애플리케이션에 따라 다르겠지만, 이제 해당 소켓에서 패킷을 사용할 수 있음을 처리 스레드에 알리는 논리가 포함될 가능성이 높습니다.

### <a name="peer-address-and-port"></a>피어 주소 및 포트   
UDP 패킷을 수신하면 애플리케이션에서 ***nx_udp_packet_info_extract*** 서비스를 사용하여 송신자의 IP 주소와 포트 번호를 찾을 수 있습니다. 성공적으로 반환되면 이 서비스는 송신자의 IP 주소, 송신자의 포트 번호, 패킷을 수신한 로컬 인터페이스에 대한 정보를 제공합니다.  

### <a name="thread-suspension"></a>스레드 일시 중단   
앞에서 설명한 대로 애플리케이션 스레드는 특정 UDP 포트에서 UDP 패킷을 수신하려 하는 동안 일시 중단할 수 있습니다. 해당 포트에서 패킷이 수신되면 패킷이 일시 중단된 첫 번째 스레드에 제공되고 해당 스레드가 다시 시작됩니다. 대부분의 NetX Duo 서비스에서 사용할 수 있는 기능인 UDP 수신 패킷을 일시 중단할 경우 선택적 시간 제한을 사용할 수 있습니다.  

### <a name="udp-socket-statistics-and-errors"></a>UDP 소켓 통계 및 오류     
사용하도록 설정된 경우 NetX Duo UDP 소켓 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다. 각 IP/UDP 인스턴스에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.

- 전송된 총 UDP 패킷  
- 전송된 총 UDP 바이트  
- 수신된 총 UDP 패킷   
- 수신된 총 UDP 바이트  
- 총 UDP 잘못된 패킷  
- 삭제된 총 UDP 수신 패킷  
- 총 UDP 수신 체크섬 오류  
- 전송된 UDP 소켓 패킷  
- 전송된 UDP 소켓 바이트  
- 수신된 UDP 소켓 패킷   
- 수신된 UDP 소켓 바이트  
- 큐에 있는 UDP 소켓 패킷  
- 삭제된 UDP 소켓 수신 패킷  
- UDP 소켓 체크섬 오류  

이 모든 통계 및 오류 보고서는 모든 UDP 소켓을 모은 UDP 통계를 위한 ***nx_udp_info_get** _ 서비스와 지정된 UDP 소켓의 UDP 통계를 위한 _ *_nx_udp_socket_info_get_** 서비스를 통해 애플리케이션에서 이용할 수 있습니다.

### <a name="udp-socket-control-block-nx_udp_socket"></a>UDP 소켓 제어 블록 NX_UDP_SOCKET
각 UDP 소켓의 특성은 관련된 NX_UDP_SOCKET 제어 블록에서 찾을 수 있습니다. IP 데이터 구조에 대한 링크, 정신 및 수신 경로에 대한 네트워크 인터페이스, 바인딩된 포트, 수신 패킷 큐와 같은 유용한 정보를 포함합니다. 이 구조는 ***nx_api.h*** 파일에서 정의됩니다.

## <a name="transmission-control-protocol-tcp"></a>TCP(Transmission Control Protocol)

TCP(Transmission Control Protocol)는 두 네트워크 멤버(RFC 793) 간의 신뢰할 수 있는 스트림 데이터 전송을 제공합니다. 한 네트워크 멤버에서 전송된 모든 데이터는 수신 멤버에 의해 확인되고 승인됩니다. 또한 두 멤버는 데이터를 전송하기 전에 연결을 설정해야 합니다. 이로 인해 신뢰할 수 있는 데이터 전송이 가능하지만 앞에서 설명한 UDP 데이터 전송보다 훨씬 많은 오버헤드를 필요로 합니다.

명시된 경우를 제외하고, IPv6는 주로 기본 IP 계층과 관련이 있기 때문에 NetX와 NetX Duo 사이에 TCP 프로토콜 API 서비스에 변경 사항이 없습니다. 모든 NetX Duo TCP 서비스는 IPv4 또는 IPv6 연결에 사용할 수 있습니다.

### <a name="tcp-header"></a>TCP 헤더   
전송 시 TCP 헤더는 사용자의 데이터 앞에 배치됩니다. 수신 시 TCP 헤더가 들어오는 패킷에서 제거되고 사용자 데이터만 애플리케이션에서 사용할 수 있습니다. TCP는 IP 프로토콜을 활용하여 패킷을 주고받는데, 이는 패킷이 네트워크에 있을 때 TCP 헤더 앞에 IP 헤더가 있다는 것을 의미합니다. 그림 13에서는 TCP 헤더의 형식을 보여줍니다.

![TCP 헤더 형식 다이어그램입니다.](./media/user-guide/image22.png)

### <a name="figure-13-tcp-header"></a>그림 13. TCP 헤더

다음은 TCP 헤더 형식에 대한 설명입니다.

|헤더&nbsp;필드 |목적 |
|------|------|
| **16비트 소스 포트 번호** | 이 필드에는 TCP 패킷이 전송되는 포트가 포함되어 있습니다. 유효한 TCP 포트 범위는 1에서 0xFFFF까지입니다. |
| **16비트 대상 포트** | 이 필드에는 패킷이 전송되는 TCP 포트가 포함되어 있습니다. 유효한 TCP 포트 범위는 1에서 0xFFFF까지입니다. |
| **32비트 시퀀스 번호** | 이 필드에는 연결의 이쪽 끝에서 전송된 데이터의 시퀀스 번호가 포함되어 있습니다. 원래 시퀀스는 두 TCP 노드 간의 초기 연결 시퀀스 중에 설정됩니다. 해당 지점에서 데이터를 전송할 때마다 시퀀스 번호가 전송된 바이트 양만큼 증가합니다. |
| **32비트 승인 번호** | 이 필드에는 연결의 이 쪽에서 마지막으로 수신된 바이트에 해당하는 시퀀스 번호가 포함되어 있습니다. 이는 이전에 전송된 데이터가 연결의 다른 쪽 끝에서 성공적으로 수신되었는지 여부를 확인하는 데 사용됩니다. |
| **4비트 헤더 길이** | 이 필드에는 TCP 헤더의 32비트 단어 수가 포함되어 있습니다. TCP 헤더에 옵션이 없는 경우 이 필드는 5입니다. |
| **6비트 코드 비트** |이 필드에는 연결과 관련된 다양한 제어 정보를 나타내는 데 사용되는 6개의 서로 다른 코드 비트가 포함되어 있습니다. 제어 비트는 다음과 같이 정의됩니다.<br \> - URG(21): 긴급 데이터 표시<br \> - ACK(20): 승인 번호 유효<br \> - PSH(19): 이 데이터 즉시 처리<br \> - RST(18): 연결 다시 설정<br \> - SYN(17): 시퀀스 번호 동기화(연결 설정에 사용)<br \> - FIN(16): 보낸 사람 전송 완료(연결 종료에 사용) |
|**16비트 창** |이 필드는 흐름 제어에 사용됩니다. 소켓이 현재 수신할 수 있는 바이트의 양이 포함됩니다. 이는 기본적으로 흐름 제어에 사용됩니다. 보낸 사람은 전송할 데이터가 받는 사람의 보급된 창에 맞는지 확인해야 합니다. |
|**16비트 TCP 체크섬** |이 필드에는 TCP 헤더, 패킷 데이터 영역, 의사 IP 헤더를 포함하는 패킷에 대한 16비트 체크섬이 포함됩니다. |
|**16비트 긴급 포인터** |이 필드에는 긴급 데이터의 마지막 바이트의 양수 오프셋이 포함됩니다. 이 필드는 URG 코드 비트가 헤더에 설정된 경우에만 유효합니다. |

> [!NOTE]  
> TCP/IP 구현의 모든 헤더는 **big endian** 형식이어야 합니다. 이 형식에서 단어의 가장 중요한 바이트는 가장 낮은 바이트 주소에 있습니다.

### <a name="tcp-enable"></a>TCP 사용       
TCP 연결 및 패킷 전송을 사용하려면 먼저 애플리케이션이 ***nx_tcp_enable*** 서비스를 호출하여 TCP를 사용하도록 설정해야 합니다. 사용하도록 설정된 후 애플리케이션은 모든 TCP 서비스에 자유롭게 액세스할 수 있습니다.  

### <a name="tcp-socket-create"></a>TCP 소켓 만들기    
TCP 소켓은 초기화 중에 또는 애플리케이션 스레드에 의한 런타임 중에 만들어집니다. 초기 서비스 형식, TTL(Time to Live), 창 크기는 ***nx_tcp_socket_create*** 서비스에 의해 정의됩니다. 애플리케이션의 TCP 소켓 수에는 제한이 없습니다.  

### <a name="tcp-checksum"></a>TCP 체크섬     
TCP는 IP 의사 헤더(소스 IP 주소, 대상 IP 주소, 프로토콜/길이 IP 단어로 구성), TCP 헤더, TCP 패킷 데이터를 포함하는 1의 보수 16비트 체크섬을 지정합니다. IPv4와 IPv6 TCP 패킷 헤더 체크섬의 유일한 차이점은 소스 및 대상 IP 주소가 IPv4에서는 32비트이고 IPv6에서는 128비트라는 점입니다. 

특정 네트워크 컨트롤러는 하드웨어에서 TCP 체크섬 계산 및 유효성 검사를 수행할 수 있습니다. 이러한 시스템의 경우, 애플리케이션은 런타임 오버헤드를 줄이기 위해 가능한 한 많은 하드웨어 체크섬 논리를 사용해야 할 수 있습니다. 애플리케이션은 빌드 시 ***NX_DISABLE_TCP_TX_CHECKSUM** _ 및 _*_NX_DISABLE_TCP_RX_CHECKSUM_**을 정의하여 NetX Duo 라이브러리에서 TCP 체크섬 계산 논리를 모두 사용하지 않도록 설정할 수 있습니다. 이렇게 하면 TCP 체크섬 코드는 컴파일되지 않습니다. 그러나 선택적 NetX Duo IPsec 패키지가 설치되어 있고 TCP 연결이 보안 채널을 통해 트래버스해야 하는 경우에는 주의해야 합니다. 이 경우 TCP 연결에 속하는 패킷의 데이터는 이미 암호화되어 있으며, 네트워크 드라이버에 있는 대부분의 하드웨어 TCP 체크섬 모듈은 암호화된 TCP 페이로드에서 올바른 체크섬 값을 생성할 수 없습니다.

이 문제를 해결하기 위해 애플리케이션은 TCP 체크섬 논리를 라이브러리에서 사용할 수 있도록 유지하고 인터페이스 기능을 사용해야 합니다. 인터페이스 기능을 사용하도록 설정하면 TCP 모듈은 드라이버가 체크섬 값을 계산할 수 있는 경우 TCP 체크섬을 올바르게 처리할 수 있습니다.

1) TCP 패킷이 IPsec 프로세스의 적용을 받지 않는 경우 네트워크 인터페이스 하드웨어는 체크섬을 계산할 수 있습니다. 따라서 TCP 모듈은 체크섬 계산을 시도하지 않습니다.

2) IPsec 패키지가 설치되어 있고 TCP 패킷이 IPsec 프로세스의 적용을 받는 경우, TCP 모듈은 패킷을 IPsec 계층으로 전송하기 전에 소프트웨어에서 체크섬을 계산합니다.

### <a name="tcp-port"></a>TCP 포트     
TCP 포트는 TCP 프로토콜의 논리적 연결 지점입니다. NetX Duo의 TCP 구성 요소에는 65,535개의 유효한 포트가 있으며, 범위는 1~0xFFFF입니다. 한 포트의 데이터를 다른 대상 포트로 전송할 수 있는 UDP와 달리 TCP 포트는 다른 특정 TCP 포트에 연결되며 이 연결이 설정될 때, 연결을 구성하는 두 포트 사이에서만 데이터 전송이 가능합니다.

> [!IMPORTANT]
> TCP 포트는 UDP 포트와 완전히 분리되어 있습니다. 예를 들어, UDP 포트 번호 1은 TCP 포트 번호 1과 관련이 없습니다.

### <a name="client-server-model"></a>클라이언트 서버 모델     
데이터 전송에 TCP를 사용하려면 먼저 두 TCP 소켓 사이에 연결을 설정해야 합니다. 연결 설정은 클라이언트 서버 방식으로 수행됩니다. 연결의 클라이언트 쪽은 연결을 시작하는 쪽이고, 서버 쪽은 처리가 완료되기 전에 클라이언트 연결 요청을 기다리기만 합니다.

> [!IMPORTANT]
> 멀티홈 디바이스의 경우, NetX Duo는 연결에 사용할 소스 주소와 연결의 대상 IP 주소를 기반으로 다음 홉 주소를 자동으로 결정합니다. TCP는 유니캐스트(예: 비방송) 대상 주소에 패킷을 전송하는 것으로 제한되기 때문에 NetX Duo는 소스 IPv6 주소를 선택하기 위한 “힌트”가 필요하지 않습니다.

### <a name="tcp-socket-state-machine"></a>TCP 소켓 상태 시스템      
두 TCP 소켓(하나의 클라이언트와 하나의 서버) 간의 연결이 복잡하며 상태 시스템 방식으로 관리됩니다. 각 TCP 소켓은 CLOSED 상태로 시작됩니다. 연결 이벤트를 통해 각 소켓의 상태 시스템은 TCP 데이터 전송의 대부분을 ESTABLISHED 상태로 마이그레이션합니다. 연결의 한쪽이 더 이상 데이터를 전송하지 않으려는 경우 연결이 끊어집니다. 다른 쪽의 연결이 끊긴 후, 결국 TCP 소켓은 CLOSED 상태로 돌아갑니다. 이 프로세스는 TCP 클라이언트와 서버가 연결을 설정하고 닫을 때마다 반복됩니다. 그림 14에서는 TCP 상태 시스템의 다양한 상태를 보여줍니다.

### <a name="tcp-client-connection"></a>TCP 클라이언트 연결       
앞에서 설명한 대로 TCP 연결의 클라이언트 측에서 TCP 서버에 대한 연결 요청을 시작합니다. 연결 요청을 하려면 먼저 클라이언트 IP 인스턴스에서 TCP를 사용하도록 설정해야 합니다. 또한 클라이언트 TCP 소켓은 다음에 ***nx_tcp_socket_create** _ 서비스를 사용하여 만들고 _ *_nx_tcp_client_socket_bind_** 서비스를 통해 포트에 바인딩되어야 합니다.

클라이언트 소켓이 바인딩된 후에는 ***nxd_tcp_client_socket_connect*** 서비스를 사용하여 TCP 서버와의 연결을 설정합니다. 연결 시도를 시작하려면 소켓이 CLOSED 상태여야 합니다. 연결 설정은 NetX Duo가 SYN 패킷을 실행한 다음 서버에서 SYN ACK 패킷을 다시 대기하는 것으로 시작하며 이는 연결 요청에 대한 승인을 나타냅니다. SYN ACK가 수신되면 NetX Duo는 ACK 패킷으로 응답하고 클라이언트 소켓을 ESTABLISHED 상태로 수준을 올립니다.

![TCP 상태 시스템의 상태 다이어그램입니다.](./media/user-guide/image24.png)   

**그림 14. TCP 상태 시스템의 상태**


> [!WARNING]
> 애플리케이션은 IPv4 및 IPv6 TCP 연결에 대해 **nxd_tcp_client_socket_connect** 를 사용해야 합니다. 여전히 애플리케이션은 IPv4 TCP 연결에 대한 **nx_tcp_client_socket_connect** 를 사용할 수 있지만 **nx_tcp_client_socket_connect** 가 결국 더 이상 사용되지 않으므로 개발자는 **nxd_tcp_client_socket_connect** 를 사용할 것을 권장합니다.

마찬가지로 **nxd_tcp_socket_peer_info_get** 은 IPv4 또는 IPv6 TCP 연결을 사용합니다. 그러나 레거시 애플리케이션에서는 **nx_tcp_socket_peer_info_get** 을 계속 사용할 수 있습니다. 개발자는 앞으로 **nxd_tcp_socket_peer_info_get** 을 사용할 것을 권장합니다.

### <a name="tcp-client-disconnection"></a>TCP 클라이언트 연결 끊기    
***nx_tcp_socket_disconnect*** 를 호출하여 연결을 닫습니다. 일시 중단이 지정되지 않은 경우 클라이언트 소켓은 RST 패킷을 서버 소켓으로 전송하고 소켓을 CLOSED 상태로 둡니다. 그러지 않고 일시 중단이 요청되면 다음과 같이 전체 TCP 연결 끊기 프로토콜이 수행됩니다. 

- 서버가 이전에 연결 끊기 요청을 시작한 경우(클라이언트 소켓이 이미 FIN 패킷을 수신하여 ACK로 응답하고 CLOSE WAIT 상태에 있음), NetX Duo는 클라이언트 TCP 소켓 상태를 LAST ACK 상태로 승격하고 FIN 패킷을 전송합니다. 그런 다음 서버로부터 ACK를 기다렸다가 연결을 끊고 CLOSED 상태로 들어갑니다.

- 반면에 클라이언트가 연결 해제 요청을 가장 먼저 시작하는 경우(서버는 연결이 끊기지 않았으며 소켓은 여전히 ESTABLISHED 상태) NetX Duo는 연결을 해제하기 위해 FIN 패킷을 전송하고 서버로부터 FIN과 ACK를 받기 위해 대기한 후 연결을 완전히 끊고 소켓을 CLOSED 상태로 둡니다.

소켓 전송 큐에 여전히 패킷이 있는 경우 NetX Duo는 패킷을 승인할 수 있도록 지정된 시간 제한을 일시 중단합니다. 시간 제한이 만료되면 NetX Duo는 클라이언트 소켓의 전송 큐를 비웁니다. 

클라이언트 소켓에서 포트의 바인딩을 해제하기 위해 애플리케이션은 ***nx_tcp_client_socket_unbind*** 를 호출합니다. 포트가 해제되기 전에 소켓이 CLOSED 상태이거나 연결을 끊는 중(TIMED WAIT 상태)이어야 합니다. 그러지 않으면 오류가 반환됩니다.

마지막으로, 애플리케이션이 더 이상 클라이언트 소켓을 필요로 하지 않으면 ***nx_tcp_socket_delete*** 를 호출하여 소켓을 삭제합니다.

### <a name="tcp-server-connection"></a>TCP 서버 연결      
TCP 연결의 서버 측은 수동적입니다. 즉, 서버는 클라이언트가 연결 요청을 시작할 때까지 기다립니다. 클라이언트 연결을 허용하려면 먼저 ***nx_tcp_enable** _ 서비스를 호출하여 IP 인스턴스에서 TCP를 사용하도록 설정해야 합니다. 다음으로 애플리케이션은 _ _nx_tcp_socket_create_* 서비스를 사용하여 TCP 소켓을 만들어야 합니다.  

서버 소켓이 연결 요청을 수신 대기하도록 설정되어야 합니다. 이 작업은 ***nx_tcp_server_socket_listen*** 서비스를 사용하여 수행됩니다. 이 서비스는 서버 소켓을 LISTEN 상태로 두고 지정된 서버 포트를 소켓에 바인딩합니다.

> [!NOTE] 
> 소켓 수신 대기 콜백 루틴을 설정하기 위해 애플리케이션은 **nx_tcp_server_socket_listen** 서비스의 tcp_listen_callback 인수에 대해 적절한 콜백 함수를 지정합니다. 그런 다음 이 애플리케이션 콜백 함수는 이 서버 포트에서 새로운 연결이 요청될 때마다 NetX Duo에 의해 실행됩니다. 콜백의 처리는 애플리케이션 제어 중입니다.

클라이언트 연결 요청을 수락하기 위해 애플리케이션은 ***nx_tcp_server_socket_accept** _ 서비스를 호출합니다. 수락 서비스를 호출하려면 서버 소켓이 LISTEN 상태 또는 SYN RECEIVED 상태(즉, 서버가 LISTEN 상태이고 연결을 요청하는 클라이언트로부터 SYN 패킷을 수신함)여야 합니다. _ *_nx_tcp_server_socket_accept_**에서 성공적으로 반환되면 연결이 설정되었으며 서버 소켓이 ESTABLISHED 상태에 있음을 나타냅니다.

서버 소켓에 유효한 연결이 있으면 추가 클라이언트 연결 요청이 *listen_queue_size* 에 의해 지정된 깊이까지 큐에 대기하고 ***nx_tcp_server_socket_listen** _ 서비스에 전달됩니다. 서버 포트에서 후속 연결을 처리하려면 애플리케이션은 사용 가능한 소켓(즉, CLOSED 상태의 소켓)을 사용하여 _ *_nx_tcp_server_socket_relisten_**를 호출해야 합니다. 소켓과 연결된 이전 연결이 완료되고 소켓이 CLOSED 상태인 경우 동일한 서버 소켓을 사용할 수 있습니다.

### <a name="tcp-server-disconnection"></a>TCP 서버 연결 끊기     
***nx_tcp_socket_disconnect*** 를 호출하여 연결을 닫습니다. 일시 중단이 지정되지 않은 경우 서버 소켓은 RST 패킷을 클라이언트 소켓으로 전송하고 소켓을 CLOSED 상태로 둡니다. 그러지 않고 일시 중단이 요청되면 다음과 같이 전체 TCP 연결 끊기 프로토콜이 수행됩니다.

- 클라이언트가 이전에 연결 끊기 요청을 시작한 경우(서버 소켓이 이미 FIN 패킷을 수신하여 ACK로 응답하고 CLOSE WAIT 상태에 있음), NetX Duo는 TCP 소켓 상태를 LAST ACK 상태로 승격하고 FIN 패킷을 전송합니다. 그런 다음 클라이언트로부터 ACK를 기다렸다가 연결을 끊고 CLOSED 상태로 들어갑니다.

- 반면에 서버가 연결 해제 요청을 가장 먼저 시작하는 경우(클라이언트는 연결이 끊기지 않았으며 소켓은 여전히 ESTABLISHED 상태) NetX Duo는 연결을 해제하기 위해 FIN 패킷을 전송하고 클라이언트로부터 FIN과 ACK를 받기 위해 대기한 후 연결을 완전히 끊고 소켓을 CLOSED 상태로 둡니다.

소켓 전송 큐에 여전히 패킷이 있는 경우 NetX Duo는 패킷을 승인할 수 있도록 지정된 시간 제한을 일시 중단합니다. 시간 제한이 만료되면 NetX Duo는 서버 소켓의 전송 큐를 플러시합니다.

연결 끊기 처리가 완료되고 서버 소켓이 CLOSED 상태이면 애플리케이션은 ***nx_tcp_server_socket_unaccept** _ 서비스를 호출하여 이 소켓과 서버 포트와의 연결을 종료해야 합니다. _*_nx_tcp_socket_disconnect_*_ 또는 _*_nx_tcp_server_socket_accept_*_ 를 오류 상태로 반환하는 경우에도 애플리케이션에서 이 서비스를 호출해야 합니다. _*_nx_tcp_server_socket_unaccept_*_ 를 반환한 후, 소켓을 클라이언트나 서버 소켓으로 사용할 수 있으며 더 이상 필요하지 않은 경우에는 삭제할 수도 있습니다. 동일한 서버 포트에서 다른 클라이언트 연결을 허용하려면 이 소켓에서 _ *_nx_tcp_server_socket_relisten_** 서비스를 호출해야 합니다.

다음 코드 세그먼트는 일반적인 TCP 서버가 사용하는 호출 시퀀스를 보여줍니다.

```c
/* Set up a previously created TCP socket to
   listen on port 12 */
nx_tcp_server_socket_listen()

/* Loop to make a (another) connection. */
while(1)
{
    /* Wait for a client socket connection request
       for 100 ticks. */
    nx_tcp_server_socket_accept();

    /* (Send and receive TCP messages with the TCP
       client) */

    /* Disconnect the server socket. */
    nx_tcp_socket_disconnect();

    /* Remove this server socket from listening on
       the port. */
    nx_tcp_server_socket_unaccept(&server_socket);
    /* Set up server socket to relisten on the
       same port for the next client. */
    nx_tcp_server_socket_relisten();
}
```

### <a name="mss-validation"></a>MSS 유효성 검사      
MSS(최대 세그먼트 크기)는 TCP 호스트가 기본 IP 계층에 의해 조각나지 않고 수신할 수 있는 최대 바이트 수입니다. TCP 연결 설정 단계를 수행하는 동안 양쪽 끝에서 자체 TCP MSS 값을 교환하여 보낸 사람이 받는 사람의 MSS보다 큰 TCP 데이터 세그먼트를 전송하지 않도록 합니다. NetX Duo TCP 모듈은 연결을 설정하기 전에 피어의 보급된 MSS 값의 유효성을 선택적으로 검사합니다. 기본적으로 NetX Duo는 이러한 검사를 사용하도록 설정하지 않습니다. MSS 유효성 검사를 수행하려는 애플리케이션은 NetX Duo 라이브러리를 빌드할 때 ***NX_ENABLE_TCP_MSS_CHECK** _를 정의해야 하며 최솟값은 _*_NX_TCP_MSS_MINIMUM_*_ 에 정의되어 있어야 합니다. MSS 값이 _ *_NX_TCP_MSS_MINIMUM_** 미만으로 들어오는 TCP 연결이 삭제됩니다.

### <a name="stop-listening-on-a-server-port"></a>서버 포트에서 수신 대기 중지    
애플리케이션이 이전에 ***nx_tcp_server_socket_listen** _ 서비스에 대한 호출로 이전에 지정된 서버 포트에서 클라이언트 연결 요청을 더 이상 수신 대기하지 않으려는 경우, 애플리케이션은 _ *_nx_tcp_server_socket_unlisten_** 서비스를 호출하기만 하면 됩니다. 이 서비스는 연결을 기다리는 소켓을 다시 CLOSED 상태로 두고 큐에 있는 클라이언트 연결 요청 패킷을 모두 해제합니다. 

### <a name="tcp-window-size"></a>TCP 창 크기   
연결의 설정 및 데이터 전송 단계를 수행하는 동안 각 포트는 처리할 수 있는 데이터 양을 보고합니다. 이를 창 크기라고 합니다. 데이터가 수신되고 처리되면 이 창 크기는 동적으로 조정됩니다. TCP에서 송신자는 수신자의 창에 맞는 양의 데이터만 전송할 수 있습니다. 기본적으로 창 크기는 연결의 각 방향에서 데이터 전송을 위한 흐름 제어를 제공합니다.   

### <a name="tcp-packet-send"></a>TCP 패킷 전송     
***nx_tcp_socket_send*** 함수를 호출하여 TCP 데이터 전송을 쉽게 수행할 수 있습니다. 전송 중인 데이터의 크기가 소켓의 MSS 값 또는 현재 피어 수신 창 크기 중 더 작은 값보다 클 경우, TCP 내부 논리는 전송을 위해 최소 크기(MSS, 피어 수신 창)에 맞는 데이터를 잘라냅니다. 그런 다음, 이 서비스는 체크섬 계산을 포함하여 패킷 앞에 TCP 헤더를 빌드합니다. 수신자의 창 크기가 0이 아닌 경우, 호출자는 수신자 창 크기를 채울 수 있는 만큼의 최대한 많은 데이터를 전송합니다. 수신 창이 0이 되면, 호출자는 이 패킷을 보낼 수 있을 만큼 수신자의 창 크기가 커지기를 일시 중단하고 대기할 수 있습니다. 언제든지 여러 스레드가 동일한 소켓을 통해 데이터를 전송하는 동안 스레드는 일시 중단될 수 있습니다. 

> [!WARNING]  
> NX_PACKET 구조에 있는 TCP 데이터는 긴 단어 경계에 있어야 합니다. 또한 앞에 추가 포인터와 데이터 시작 포인터 사이에 TCP, IP, 실제 미디어 헤더가 배치될 수 있도록 충분한 공간이 있어야 합니다.

### <a name="tcp-packet-retransmit"></a>TCP 패킷 재전송      
이전에 전송된 TCP 패킷은 ACK가 연결의 다른 쪽에서 반환될 때까지 실제로 내부적으로 저장됩니다. 전송된 데이터가 시간 제한 기간 내에 승인되지 않으면 저장된 패킷이 다시 전송되고 다음 시간 제한 기간이 설정됩니다. ACK가 수신되면 내부 전송 큐의 승인 번호로 처리되는 모든 패킷이 최종적으로 해제됩니다.  

> [!WARNING]   
> 애플리케이션은 NX_SUCCESS를 사용하여 nx_tcp_socket_send()를 반환한 후 패킷을 재사용하거나 패킷의 콘텐츠를 변경하지 않아야 합니다. 전송된 패킷은 데이터가 다른 쪽 끝에서 승인된 후 NetX Duo 내부 처리에 의해 최종적으로 해제됩니다.

### <a name="tcp-keepalive"></a>TCP Keepalive     
TCP Keepalive 기능을 사용하면 소켓이 적절한 종료(예: 피어 크래시) 없이 피어 연결이 끊어졌는지 여부를 감지하거나 특정 네트워크 모니터링 기능이 장시간 유휴 상태에서 연결이 종료되는 것을 방지할 수 있습니다. TCP Keepalive는 데이터가 없는 TCP 프레임을 주기적으로 전송하고, 시퀀스 번호가 현재 시퀀스 번호보다 작은 값으로 설정됨으로써 작동합니다. 활성 상태의 수신자는 해당 TCP Keepalive 프레임을 수신하면 현재 시퀀스 번호에 대해 ACK로 응답합니다. 이렇게 하면 keepalive 트랜잭션이 완료됩니다.  

기본적으로 keepalive 기능은 사용하도록 설정되지 않습니다. 이 기능을 사용하려면 ***NX_ENABLE_TCP_KEEPALIVE** _가 정의된 NetX Duo 라이브러리를 빌드해야 합니다. _ *_NX_TCP_KEEPALIVE_INITIAL_** 기호는 keepalive 프레임이 시작되기 전의 비활성 시간(초)을 지정합니다.  

### <a name="tcp-packet-receive"></a>TCP 패킷 수신   
TCP 수신 패킷 처리(IP 도우미 스레드에서 호출)는 다양한 연결 및 연결 끊기 작업뿐만 아니라 전송 승인 처리도 담당합니다. 또한 TCP 수신 패킷 처리는 수신 데이터가 있는 패킷을 적절한 TCP 소켓의 수신 큐에 배치하거나 패킷을 대기 중인 첫 번째 일시 중단된 스레드에 패킷을 전달하는 역할을 합니다.

### <a name="tcp-receive-notify"></a>TCP 수신 알림     
애플리케이션 스레드가 둘 이상의 소켓에서 받은 데이터를 처리해야 하는 경우 ***nx_tcp_socket_receive_notify*** 함수를 사용해야 합니다. 이 함수는 소켓에 대한 수신 패킷 콜백 함수를 등록합니다. 패킷이 소켓에 수신될 때마다 콜백 함수가 실행됩니다.  

콜백 함수의 콘텐츠는 애플리케이션에 따라 다르지만, 그 함수는 해당 소켓에서 패킷을 사용할 수 있다는 것을 처리 스레드에 알리는 논리를 포함할 가능성이 큽니다. 

### <a name="thread-suspension"></a>스레드 일시 중단      
앞에서 설명한 대로 애플리케이션 스레드는 특정 TCP 포트에서 데이터를 수신하는 동안 일시 중단할 수 있습니다. 해당 포트에서 패킷이 수신되면 패킷이 일시 중단된 첫 번째 스레드에 제공되고 해당 스레드가 다시 시작됩니다. 대부분의 NetX Duo 서비스에서 사용할 수 있는 기능인 TCP 수신 패킷을 일시 중단할 경우 선택적 시간 제한을 사용할 수 있습니다.  

또한 스레드 일시 중단은 연결(클라이언트 및 서버 모두), 클라이언트 바인딩, 연결 끊기 서비스에 사용할 수 있습니다.  

### <a name="tcp-socket-statistics-and-errors"></a>TCP 소켓 통계 및 오류     
사용하도록 설정된 경우 NetX Duo TCP 소켓 소프트웨어는 애플리케이션에 유용할 수 있는 몇 가지 통계 및 오류를 추적합니다. 각 IP/TCP 인스턴스에 대해 다음 통계 및 오류 보고서가 유지 관리됩니다.   

- 전송된 총 TCP 패킷  
- 전송된 총 TCP 바이트  
- 수신된 총 TCP 패킷   
- 수신된 총 TCP 바이트   
- 총 TCP 잘못된 패킷   
- 삭제된 총 TCP 수신 패킷    
- 총 TCP 수신 체크섬 오류   
- 총 TCP 연결   
- 총 TCP 연결 끊김   
- 삭제된 총 TCP 연결    
- 총 TCP 패킷 재전송   
- 전송된 TCP 소켓 패킷   
- 전송된 TCP 소켓 바이트   
- 수신된 TCP 소켓 패킷   
- 수신된 TCP 소켓 바이트   
- TCP 소켓 패킷 재전송    
- 큐에 있는 TCP 소켓 패킷    
- TCP 소켓 체크섬 오류    
- TCP 소켓 상태    
- TCP 소켓 전송 큐 깊이    
- TCP 소켓 전송 창 크기    
- TCP 소켓 수신 창 크기    

이러한 모든 통계 및 오류 보고서는 총 TCP 통계의 경우 ***nx_tcp_info_get** _ 서비스와 소켓당 TCP 통계의 경우 _ _nx_tcp_socket_info_get_* 서비스가 있는 애플리케이션에서 사용할 수 있습니다.

### <a name="tcp-socket-control-block-nx_tcp_socket"></a>TCP 소켓 제어 블록 NX_TCP_SOCKET      
각 TCP 소켓의 특징은 연결된 *NX_TCP_SOCKET* 제어 블록에서 찾을 수 있습니다. 여기에는 IP 데이터 구조에 대한 링크, 네트워크 연결 인터페이스, 바인딩된 포트, 수신 패킷 큐와 같은 유용한 정보가 포함됩니다. 이 구조는 ***nx_api.h*** 파일에서 정의됩니다.

## <a name="tcpip-offload"></a>TCP/IP 오프로드
이 기능을 통해 NetX Duo는 하드웨어에서 TCP/IP 서비스를 제공하는 네트워크 인터페이스 카드를 지원할 수 있습니다. 특정 WiFi 모듈은 모듈에서 TCP/IP 처리를 제공하고 MCU의 애플리케이션은 TCP/IP 스택에 액세스하기 위해 API를 통해 패킷을 보내고 받습니다. 이 기능을 사용하면 개발자가 네이티브 NetX Duo 애플리케이션을 직접 실행할 수 있습니다.

TCP/IP 오프로드 기능을 사용하려면 `NX_ENABLE_TCPIP_OFFLOAD` 및 `NX_ENABLE_INTERFACE_CAPABILITY`를 정의하여 NetX Duo를 빌드해야 합니다.

### <a name="tcpip-offload-handler"></a>TCP/IP 오프로드 처리기
NetX Duo는 TCP 또는 UDP 소켓 작업을 처리하는 콜백 함수를 통해 네트워크 드라이버와 통신합니다. 콜백 함수는 `NX_INTERFACE_STRUCT`에 정의되어 있습니다. 네트워크 드라이버는 `NX_LINK_ENABLE` 드라이버 명령 중에 TCP/IP 콜백 기능을 설정해야 합니다. TCP/IP 콜백 함수의 프로토타입은 다음과 같습니다.

``` C
UINT (*nx_interface_tcpip_offload_handler)(struct NX_IP_STRUCT *ip_ptr,
                                           struct NX_INTERFACE_STRUCT *interface_ptr,
                                           VOID *socket_ptr, UINT operation, NX_PACKET *packet_ptr,
                                           NXD_ADDRESS *local_ip, NXD_ADDRESS *remote_ip,
                                           UINT local_port, UINT *remote_port, UINT wait_option);
```
매개 변수에 대한 설명.
* `ip_ptr` - IP 인스턴스에 대한 포인터
* `interface_ptr` - 인터페이스에 대한 포인터
* `socket_ptr` - `NX_TCP_SOCKET` 또는 `NX_UDP_SOCKET`에 대한 포인터로, `operation` 값에 따라 다름
* `operation` - 현재 함수 호출 작업. 값은 아래와 같이 정의됩니다.
``` C
#define NX_TCPIP_OFFLOAD_TCP_CLIENT_SOCKET_CONNECT  0
#define NX_TCPIP_OFFLOAD_TCP_SERVER_SOCKET_LISTEN   1
#define NX_TCPIP_OFFLOAD_TCP_SERVER_SOCKET_ACCEPT   2
#define NX_TCPIP_OFFLOAD_TCP_SERVER_SOCKET_UNLISTEN 3
#define NX_TCPIP_OFFLOAD_TCP_SOCKET_DISCONNECT      4
#define NX_TCPIP_OFFLOAD_TCP_SOCKET_SEND            5
#define NX_TCPIP_OFFLOAD_UDP_SOCKET_BIND            6
#define NX_TCPIP_OFFLOAD_UDP_SOCKET_UNBIND          7
#define NX_TCPIP_OFFLOAD_UDP_SOCKET_SEND            8
```
* `packet_ptr` - 패킷에 대한 포인터. 값은 `operation`이 `TCP_SOCKET_SEND` 또는 `UDP_SOCKET_SEND`인 경우에 설정됩니다.
* `local_ip` -로컬 IP 주소에 대한 포인터. 값은 `operation`이 `UDP_SOCKET_SEND`인 경우에 설정됩니다.
* `remote_ip` -원격 IP 주소에 대한 포인터. 값은 `operation`이 `TCP_CLIENT_SOCKET_CONNECT` 또는 `UDP_SOCKET_SEND`인 경우에 설정됩니다. 작업이 `TCP_SERVER_SOCKET_ACCEPT`인 경우 이 값은 콜백 함수에 의해 반환되어야 합니다.
* `local_port` - 로컬 포트. 값은 `operation`이 `TCP_CLIENT_SOCKET_CONNECT`, `TCP_SERVER_SOCKET_LISTEN`, `TCP_SERVER_SOCKET_ACCEPT`, `TCP_SERVER_SOCKET_UNLISTEN` 또는 UDP인 경우에 설정됩니다.
* `remote_port` - 원격 포트. 값은 `operation`이 `TCP_CLIENT_SOCKET_CONNECT` 또는 `UDP_SOCKET_SEND`인 경우에 설정됩니다. 작업이 `TCP_SERVER_SOCKET_ACCEPT`인 경우 이 값은 콜백 함수에 의해 반환되어야 합니다.
* `wait_option` - 틱 단위의 대기 옵션입니다. 값은 모든 작업에 대해 설정됩니다.

### <a name="tcpip-offload-context"></a>TCP/IP 오프로드 컨텍스트
TCP/IP 오프로드 드라이버에서 사용할 `NX_TCP_SOCKET` 구조에 포인터가 추가되었습니다.
```
typedef struct NX_TCP_SOCKET_STRUCT
{
    // ...

    /* This pointer is designed to be accessed by TCP/IP offload directly.  */
    VOID *nx_tcp_socket_tcpip_offload_context;
} NX_TCP_SOCKET;
```

TCP/IP 오프로드 드라이버에서 사용할 `NX_UDP_SOCKET` 구조에 포인터가 추가되었습니다.
```
typedef struct NX_UDP_SOCKET_STRUCT
{
    // ...

    /* This pointer is designed to be accessed by TCP/IP offload directly.  */
    VOID *nx_udp_socket_tcpip_offload_context;
} NX_UDP_SOCKET;
```

### <a name="apis-for-tcpip-offload-network-driver"></a>TCP/IP 오프로드 네트워크 드라이버용 API
``` C
/* Invoked when TCP packet is receive or connection error.  */
VOID _nx_tcp_socket_driver_packet_receive(NX_TCP_SOCKET *socket_ptr, NX_PACKET *packet_ptr);

/* Invoked when TCP connection is establish.  */
UINT _nx_tcp_socket_driver_establish(NX_TCP_SOCKET *socket_ptr, NX_INTERFACE *interface_ptr, UINT remote_port);

/* Invoked when UDP packet is receive.  */
VOID _nx_udp_socket_driver_packet_receive(NX_UDP_SOCKET *socket_ptr, NX_PACKET *packet_ptr,
                                          NXD_ADDRESS *local_ip, NXD_ADDRESS *remote_ip, UINT remote_port);
```
### <a name="tcpip-offload-driver"></a>TCP/IP 오프로드 드라이버
각 IP 인터페이스에는 드라이버 함수가 필요합니다. NetX Duo 드라이버 함수를 개발하는 방법에 대한 자세한 내용은 [5장](chapter5.md#tcpip-offload-driver-guidance)을 참조하세요.

### <a name="tcpip-offload-known-limitations"></a>TCP/IP 오프로드의 알려진 제한 사항
- TCP 및 UDP 소켓만 지원됩니다.
- DHCP는 일반적으로 NetX Duo가 아닌 언더레이어 TCP/IP 스택에 의해 수행됩니다.
- 언더레이어 TCP/IP 스택의 기타 제한 사항